// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.RTCAdmin
{
	public sealed partial class RTCAdminInterface : Handle
	{
		public RTCAdminInterface()
		{
		}

		public RTCAdminInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="CopyUserTokenByIndexOptions" /> struct.
		/// </summary>
		public const int CopyusertokenbyindexApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="CopyUserTokenByUserIdOptions" /> struct.
		/// </summary>
		public const int CopyusertokenbyuseridApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="Kick" /> API
		/// </summary>
		public const int KickApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="QueryJoinRoomToken" /> API
		/// </summary>
		public const int QueryjoinroomtokenApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="SetParticipantHardMuteOptions" /> struct.
		/// </summary>
		public const int SetparticipanthardmuteApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UserToken" /> struct.
		/// </summary>
		public const int UsertokenApiLatest = 1;

		/// <summary>
		/// Fetches a user token when called inside of the OnQueryJoinRoomTokenComplete callback.
		/// The order of the tokens doesn't necessarily match the order of the EOS_ProductUserId array specified in the EOS_RTCAdmin_QueryJoinRoomTokenOptions when
		/// initiating the query.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the index being accessed</param>
		/// <param name="outUserToken">The user token for the given index, if it exists and is valid. Use <see cref="Release" /> when finished</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserToken
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the user token is not found
		/// </returns>
		public Result CopyUserTokenByIndex(ref CopyUserTokenByIndexOptions options, out UserToken? outUserToken)
		{
			CopyUserTokenByIndexOptionsInternal optionsInternal = new CopyUserTokenByIndexOptionsInternal();
			optionsInternal.Set(ref options);

			var outUserTokenAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_RTCAdmin_CopyUserTokenByIndex(InnerHandle, ref optionsInternal, ref outUserTokenAddress);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<UserTokenInternal, UserToken>(outUserTokenAddress, out outUserToken);
			if (outUserToken != null)
			{
				Bindings.EOS_RTCAdmin_UserToken_Release(outUserTokenAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Fetches a user token for a given user ID when called inside of the OnQueryJoinRoomTokenComplete callback.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the user ID being accessed</param>
		/// <param name="outUserToken">The user token for the given user ID, if it exists and is valid. Use <see cref="Release" /> when finished</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserToken
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the user token is not found
		/// </returns>
		public Result CopyUserTokenByUserId(ref CopyUserTokenByUserIdOptions options, out UserToken? outUserToken)
		{
			CopyUserTokenByUserIdOptionsInternal optionsInternal = new CopyUserTokenByUserIdOptionsInternal();
			optionsInternal.Set(ref options);

			var outUserTokenAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_RTCAdmin_CopyUserTokenByUserId(InnerHandle, ref optionsInternal, ref outUserTokenAddress);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<UserTokenInternal, UserToken>(outUserTokenAddress, out outUserToken);
			if (outUserToken != null)
			{
				Bindings.EOS_RTCAdmin_UserToken_Release(outUserTokenAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Starts an asynchronous task that removes a participant from a room and revokes their token.
		/// </summary>
		/// <param name="options">structure containing the room and user to revoke the token from.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		public void Kick(ref KickOptions options, object clientData, OnKickCompleteCallback completionDelegate)
		{
			KickOptionsInternal optionsInternal = new KickOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnKickCompleteCallbackInternal(OnKickCompleteCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_RTCAdmin_Kick(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Query for a list of user tokens for joining a room.
		/// 
		/// Each query generates a query id ( see <see cref="QueryJoinRoomTokenCompleteCallbackInfo" /> ) which should be used
		/// to retrieve the tokens from inside the callback.
		/// </summary>
		/// <param name="options">Structure containing information about the application whose user tokens we're retrieving.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">This function is called when the query join room token operation completes.</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public void QueryJoinRoomToken(ref QueryJoinRoomTokenOptions options, object clientData, OnQueryJoinRoomTokenCompleteCallback completionDelegate)
		{
			QueryJoinRoomTokenOptionsInternal optionsInternal = new QueryJoinRoomTokenOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnQueryJoinRoomTokenCompleteCallbackInternal(OnQueryJoinRoomTokenCompleteCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_RTCAdmin_QueryJoinRoomToken(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Starts an asynchronous task remotely mutes/unmutes a room participant.
		/// 
		/// This remotely mutes the specified participant, so no audio is sent from that participant to any other participant in the room.
		/// </summary>
		/// <param name="options">structure containing the room and user to mute.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		public void SetParticipantHardMute(ref SetParticipantHardMuteOptions options, object clientData, OnSetParticipantHardMuteCompleteCallback completionDelegate)
		{
			SetParticipantHardMuteOptionsInternal optionsInternal = new SetParticipantHardMuteOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnSetParticipantHardMuteCompleteCallbackInternal(OnSetParticipantHardMuteCompleteCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_RTCAdmin_SetParticipantHardMute(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		[MonoPInvokeCallback(typeof(OnKickCompleteCallbackInternal))]
		internal static void OnKickCompleteCallbackInternalImplementation(ref KickCompleteCallbackInfoInternal data)
		{
			OnKickCompleteCallback callback;
			KickCompleteCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnQueryJoinRoomTokenCompleteCallbackInternal))]
		internal static void OnQueryJoinRoomTokenCompleteCallbackInternalImplementation(ref QueryJoinRoomTokenCompleteCallbackInfoInternal data)
		{
			OnQueryJoinRoomTokenCompleteCallback callback;
			QueryJoinRoomTokenCompleteCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnSetParticipantHardMuteCompleteCallbackInternal))]
		internal static void OnSetParticipantHardMuteCompleteCallbackInternalImplementation(ref SetParticipantHardMuteCompleteCallbackInfoInternal data)
		{
			OnSetParticipantHardMuteCompleteCallback callback;
			SetParticipantHardMuteCompleteCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}
	}
}