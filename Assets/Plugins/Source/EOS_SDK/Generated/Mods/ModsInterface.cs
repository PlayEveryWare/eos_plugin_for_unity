// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.Mods
{
	public sealed partial class ModsInterface : Handle
	{
		public ModsInterface()
		{
		}

		public ModsInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="CopyModInfoOptions" /> API.
		/// </summary>
		public const int CopymodinfoApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="EnumerateModsOptions" /> API.
		/// </summary>
		public const int EnumeratemodsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="InstallMod" /> API.
		/// </summary>
		public const int InstallmodApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="ModIdentifier" /> struct.
		/// </summary>
		public const int ModIdentifierApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="ModInfo" /> struct.
		/// </summary>
		public const int ModinfoApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UninstallModOptions" /> API.
		/// </summary>
		public const int UninstallmodApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UpdateModOptions" /> API.
		/// </summary>
		public const int UpdatemodApiLatest = 1;

		/// <summary>
		/// Get cached enumerated mods object. If successful, this data must be released by calling <see cref="Release" />
		/// Types of the cached enumerated mods can be specified through <see cref="CopyModInfoOptions" />
		/// <seealso cref="Release" />
		/// This request may fail with an <seealso cref="Result.NotFound" /> code if an enumeration of a certain type was not performed before this call.
		/// </summary>
		/// <param name="options">structure containing the game identifier for which requesting enumerated mods</param>
		/// <param name="outEnumeratedMods">Enumerated mods Info. If the returned result is success, this will be set to data that must be later released, otherwise this will be set to <see langword="null" /></param>
		/// <returns>
		/// Success if we have cached data, or an error result if the request was invalid or we do not have cached data.
		/// </returns>
		public Result CopyModInfo(ref CopyModInfoOptions options, out ModInfo? outEnumeratedMods)
		{
			CopyModInfoOptionsInternal optionsInternal = new CopyModInfoOptionsInternal();
			optionsInternal.Set(ref options);

			var outEnumeratedModsAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Mods_CopyModInfo(InnerHandle, ref optionsInternal, ref outEnumeratedModsAddress);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<ModInfoInternal, ModInfo>(outEnumeratedModsAddress, out outEnumeratedMods);
			if (outEnumeratedMods != null)
			{
				Bindings.EOS_Mods_ModInfo_Release(outEnumeratedModsAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to enumerate mods for the specified game.
		/// Types of the mods to enumerate can be specified through <see cref="EnumerateModsOptions" />
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">structure containing the game identifiers</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		public void EnumerateMods(ref EnumerateModsOptions options, object clientData, OnEnumerateModsCallback completionDelegate)
		{
			EnumerateModsOptionsInternal optionsInternal = new EnumerateModsOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnEnumerateModsCallbackInternal(OnEnumerateModsCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Mods_EnumerateMods(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to install the specified mod.
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">structure containing the game and mod identifiers</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		public void InstallMod(ref InstallModOptions options, object clientData, OnInstallModCallback completionDelegate)
		{
			InstallModOptionsInternal optionsInternal = new InstallModOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnInstallModCallbackInternal(OnInstallModCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Mods_InstallMod(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to uninstall the specified mod.
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">structure containing the game and mod identifiers</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		public void UninstallMod(ref UninstallModOptions options, object clientData, OnUninstallModCallback completionDelegate)
		{
			UninstallModOptionsInternal optionsInternal = new UninstallModOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnUninstallModCallbackInternal(OnUninstallModCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Mods_UninstallMod(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to update the specified mod to the latest version.
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">structure containing the game and mod identifiers</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error. If the mod is up to date then the operation will complete with success.</param>
		public void UpdateMod(ref UpdateModOptions options, object clientData, OnUpdateModCallback completionDelegate)
		{
			UpdateModOptionsInternal optionsInternal = new UpdateModOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnUpdateModCallbackInternal(OnUpdateModCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Mods_UpdateMod(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		[MonoPInvokeCallback(typeof(OnEnumerateModsCallbackInternal))]
		internal static void OnEnumerateModsCallbackInternalImplementation(ref EnumerateModsCallbackInfoInternal data)
		{
			OnEnumerateModsCallback callback;
			EnumerateModsCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnInstallModCallbackInternal))]
		internal static void OnInstallModCallbackInternalImplementation(ref InstallModCallbackInfoInternal data)
		{
			OnInstallModCallback callback;
			InstallModCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnUninstallModCallbackInternal))]
		internal static void OnUninstallModCallbackInternalImplementation(ref UninstallModCallbackInfoInternal data)
		{
			OnUninstallModCallback callback;
			UninstallModCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnUpdateModCallbackInternal))]
		internal static void OnUpdateModCallbackInternalImplementation(ref UpdateModCallbackInfoInternal data)
		{
			OnUpdateModCallback callback;
			UpdateModCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}
	}
}