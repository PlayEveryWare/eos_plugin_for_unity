// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.Mods
{
	public sealed partial class ModsInterface : Handle
	{
		public ModsInterface()
		{
		}

		public ModsInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="CopyModInfoOptions" /> API.
		/// </summary>
		public const int CopymodinfoApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="EnumerateModsOptions" /> API.
		/// </summary>
		public const int EnumeratemodsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="InstallMod" /> API.
		/// </summary>
		public const int InstallmodApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="ModIdentifier" /> struct.
		/// </summary>
		public const int ModIdentifierApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="ModInfo" /> struct.
		/// </summary>
		public const int ModinfoApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UninstallModOptions" /> API.
		/// </summary>
		public const int UninstallmodApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UpdateModOptions" /> API.
		/// </summary>
		public const int UpdatemodApiLatest = 1;

		/// <summary>
		/// Get cached enumerated mods object. If successful, this data must be released by calling <see cref="Release" />
		/// Types of the cached enumerated mods can be specified through <see cref="CopyModInfoOptions" />
		/// <seealso cref="Release" />
		/// This request may fail with an <seealso cref="Result.NotFound" /> code if an enumeration of a certain type was not performed before this call.
		/// </summary>
		/// <param name="options">structure containing the game identifier for which requesting enumerated mods</param>
		/// <param name="outEnumeratedMods">Enumerated mods Info. If the returned result is success, this will be set to data that must be later released, otherwise this will be set to NULL</param>
		/// <returns>
		/// Success if we have cached data, or an error result if the request was invalid or we do not have cached data.
		/// </returns>
		public Result CopyModInfo(CopyModInfoOptions options, out ModInfo outEnumeratedMods)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyModInfoOptionsInternal, CopyModInfoOptions>(ref optionsAddress, options);

			var outEnumeratedModsAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Mods_CopyModInfo(InnerHandle, optionsAddress, ref outEnumeratedModsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			if (Helper.TryMarshalGet<ModInfoInternal, ModInfo>(outEnumeratedModsAddress, out outEnumeratedMods))
			{
				Bindings.EOS_Mods_ModInfo_Release(outEnumeratedModsAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to enumerate mods for the specified game.
		/// Types of the mods to enumerate can be specified through <see cref="EnumerateModsOptions" />
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">structure containing the game identifiers</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		public void EnumerateMods(EnumerateModsOptions options, object clientData, OnEnumerateModsCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<EnumerateModsOptionsInternal, EnumerateModsOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnEnumerateModsCallbackInternal(OnEnumerateModsCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Mods_EnumerateMods(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to install the specified mod.
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">structure containing the game and mod identifiers</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		public void InstallMod(InstallModOptions options, object clientData, OnInstallModCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<InstallModOptionsInternal, InstallModOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnInstallModCallbackInternal(OnInstallModCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Mods_InstallMod(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to uninstall the specified mod.
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">structure containing the game and mod identifiers</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		public void UninstallMod(UninstallModOptions options, object clientData, OnUninstallModCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<UninstallModOptionsInternal, UninstallModOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnUninstallModCallbackInternal(OnUninstallModCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Mods_UninstallMod(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to update the specified mod to the latest version.
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">structure containing the game and mod identifiers</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error. If the mod is up to date then the operation will complete with success.</param>
		public void UpdateMod(UpdateModOptions options, object clientData, OnUpdateModCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<UpdateModOptionsInternal, UpdateModOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnUpdateModCallbackInternal(OnUpdateModCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Mods_UpdateMod(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		[MonoPInvokeCallback(typeof(OnEnumerateModsCallbackInternal))]
		internal static void OnEnumerateModsCallbackInternalImplementation(System.IntPtr data)
		{
			OnEnumerateModsCallback callback;
			EnumerateModsCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnEnumerateModsCallback, EnumerateModsCallbackInfoInternal, EnumerateModsCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnInstallModCallbackInternal))]
		internal static void OnInstallModCallbackInternalImplementation(System.IntPtr data)
		{
			OnInstallModCallback callback;
			InstallModCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnInstallModCallback, InstallModCallbackInfoInternal, InstallModCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnUninstallModCallbackInternal))]
		internal static void OnUninstallModCallbackInternalImplementation(System.IntPtr data)
		{
			OnUninstallModCallback callback;
			UninstallModCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnUninstallModCallback, UninstallModCallbackInfoInternal, UninstallModCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnUpdateModCallbackInternal))]
		internal static void OnUpdateModCallbackInternalImplementation(System.IntPtr data)
		{
			OnUpdateModCallback callback;
			UpdateModCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnUpdateModCallback, UpdateModCallbackInfoInternal, UpdateModCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}
	}
}