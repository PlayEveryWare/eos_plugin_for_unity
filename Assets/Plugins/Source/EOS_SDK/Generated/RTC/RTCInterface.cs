// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.RTC
{
	public sealed partial class RTCInterface : Handle
	{
		public RTCInterface()
		{
		}

		public RTCInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyDisconnected" /> API.
		/// </summary>
		public const int AddnotifydisconnectedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyParticipantStatusChanged" /> API.
		/// </summary>
		public const int AddnotifyparticipantstatuschangedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="BlockParticipant" /> API.
		/// </summary>
		public const int BlockparticipantApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="JoinRoom" /> API.
		/// </summary>
		public const int JoinroomApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="LeaveRoom" /> API.
		/// </summary>
		public const int LeaveroomApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="ParticipantMetadata" /> struct.
		/// </summary>
		public const int ParticipantmetadataApiLatest = 1;

		public const int ParticipantmetadataKeyMaxcharcount = 256;

		public const int ParticipantmetadataValueMaxcharcount = 256;

		/// <summary>
		/// Register to receive notifications when disconnected from the room. If the returned NotificationId is valid, you must call
		/// <see cref="RemoveNotifyDisconnected" /> when you no longer wish to have your CompletionDelegate called.
		/// 
		/// This function will always return <see cref="Common.InvalidNotificationid" /> when used with lobby RTC room. To be notified of the connection
		/// status of a Lobby-managed RTC room, use the <see cref="Lobby.LobbyInterface.AddNotifyRTCRoomConnectionChanged" /> function instead.
		/// <seealso cref="Common.InvalidNotificationid" />
		/// <seealso cref="RemoveNotifyDisconnected" />
		/// </summary>
		/// <param name="clientData">Arbitrary data that is passed back in the CompletionDelegate</param>
		/// <param name="completionDelegate">The callback to be fired when a presence change occurs</param>
		/// <returns>
		/// Notification ID representing the registered callback if successful, an invalid NotificationId if not
		/// </returns>
		public ulong AddNotifyDisconnected(AddNotifyDisconnectedOptions options, object clientData, OnDisconnectedCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyDisconnectedOptionsInternal, AddNotifyDisconnectedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnDisconnectedCallbackInternal(OnDisconnectedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			var funcResult = Bindings.EOS_RTC_AddNotifyDisconnected(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications when a participant's status changes (e.g: join or leave the room). If the returned NotificationId is valid, you must call
		/// <see cref="RemoveNotifyParticipantStatusChanged" /> when you no longer wish to have your CompletionDelegate called.
		/// 
		/// If you register to this notification before joining a room, you will receive a notification for every member already in the room when you join said room.
		/// This allows you to know who is already in the room when you join.
		/// 
		/// To be used effectively with a Lobby-managed RTC room, this should be registered during the <see cref="Lobby.LobbyInterface.CreateLobby" /> or <see cref="Lobby.LobbyInterface.JoinLobby" /> completion
		/// callbacks when the ResultCode is <see cref="Result.Success" />. If this notification is registered after that point, it is possible to miss notifications for
		/// already-existing room participants.
		/// <seealso cref="Common.InvalidNotificationid" />
		/// <seealso cref="RemoveNotifyParticipantStatusChanged" />
		/// </summary>
		/// <param name="clientData">Arbitrary data that is passed back in the CompletionDelegate</param>
		/// <param name="completionDelegate">The callback to be fired when a presence change occurs</param>
		/// <returns>
		/// Notification ID representing the registered callback if successful, an invalid NotificationId if not
		/// @note This notification is also raised when the local user joins the room, but NOT when the local user leaves the room.
		/// </returns>
		public ulong AddNotifyParticipantStatusChanged(AddNotifyParticipantStatusChangedOptions options, object clientData, OnParticipantStatusChangedCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyParticipantStatusChangedOptionsInternal, AddNotifyParticipantStatusChangedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnParticipantStatusChangedCallbackInternal(OnParticipantStatusChangedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			var funcResult = Bindings.EOS_RTC_AddNotifyParticipantStatusChanged(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Use this function to block a participant already connected to the room. After blocking them no media will be sent or received between
		/// that user and the local user. This method can be used after receiving the OnParticipantStatusChanged notification.
		/// </summary>
		/// <param name="options">structure containing the parameters for the operation.</param>
		/// <param name="clientData">Arbitrary data that is passed back in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation succeeded
		/// <see cref="Result.InvalidParameters" /> if any of the parameters are incorrect
		/// <see cref="Result.NotFound" /> if either the local user or specified participant are not in the specified room
		/// </returns>
		public void BlockParticipant(BlockParticipantOptions options, object clientData, OnBlockParticipantCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<BlockParticipantOptionsInternal, BlockParticipantOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnBlockParticipantCallbackInternal(OnBlockParticipantCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_RTC_BlockParticipant(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Get a handle to the Audio interface
		/// eos_rtc_audio.h
		/// eos_rtc_audio_types.h
		/// </summary>
		/// <returns>
		/// <see cref="RTCAudio.RTCAudioInterface" /> handle
		/// </returns>
		public RTCAudio.RTCAudioInterface GetAudioInterface()
		{
			var funcResult = Bindings.EOS_RTC_GetAudioInterface(InnerHandle);

			RTCAudio.RTCAudioInterface funcResultReturn;
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Use this function to join a room.
		/// 
		/// This function does not need to called for the Lobby RTC Room system; doing so will return <see cref="Result.AccessDenied" />. The lobby system will
		/// automatically join and leave RTC Rooms for all lobbies that have RTC rooms enabled.
		/// </summary>
		/// <param name="options">structure containing the parameters for the operation.</param>
		/// <param name="clientData">Arbitrary data that is passed back in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		public void JoinRoom(JoinRoomOptions options, object clientData, OnJoinRoomCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<JoinRoomOptionsInternal, JoinRoomOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnJoinRoomCallbackInternal(OnJoinRoomCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_RTC_JoinRoom(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Use this function to leave a room and clean up all the resources associated with it. This function has to always be called when the
		/// room is abandoned even if the user is already disconnected for other reasons.
		/// 
		/// This function does not need to called for the Lobby RTC Room system; doing so will return <see cref="Result.AccessDenied" />. The lobby system will
		/// automatically join and leave RTC Rooms for all lobbies that have RTC rooms enabled.
		/// </summary>
		/// <param name="options">structure containing the parameters for the operation.</param>
		/// <param name="clientData">Arbitrary data that is passed back in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation succeeded
		/// <see cref="Result.InvalidParameters" /> if any of the parameters are incorrect
		/// <see cref="Result.NotFound" /> if not in the specified room
		/// </returns>
		public void LeaveRoom(LeaveRoomOptions options, object clientData, OnLeaveRoomCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<LeaveRoomOptionsInternal, LeaveRoomOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnLeaveRoomCallbackInternal(OnLeaveRoomCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_RTC_LeaveRoom(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Unregister a previously bound notification handler from receiving room disconnection notifications
		/// </summary>
		/// <param name="notificationId">The Notification ID representing the registered callback</param>
		public void RemoveNotifyDisconnected(ulong notificationId)
		{
			Helper.TryRemoveCallbackByNotificationId(notificationId);

			Bindings.EOS_RTC_RemoveNotifyDisconnected(InnerHandle, notificationId);
		}

		/// <summary>
		/// Unregister a previously bound notification handler from receiving participant status change notifications
		/// </summary>
		/// <param name="notificationId">The Notification ID representing the registered callback</param>
		public void RemoveNotifyParticipantStatusChanged(ulong notificationId)
		{
			Helper.TryRemoveCallbackByNotificationId(notificationId);

			Bindings.EOS_RTC_RemoveNotifyParticipantStatusChanged(InnerHandle, notificationId);
		}

		[MonoPInvokeCallback(typeof(OnBlockParticipantCallbackInternal))]
		internal static void OnBlockParticipantCallbackInternalImplementation(System.IntPtr data)
		{
			OnBlockParticipantCallback callback;
			BlockParticipantCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnBlockParticipantCallback, BlockParticipantCallbackInfoInternal, BlockParticipantCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnDisconnectedCallbackInternal))]
		internal static void OnDisconnectedCallbackInternalImplementation(System.IntPtr data)
		{
			OnDisconnectedCallback callback;
			DisconnectedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnDisconnectedCallback, DisconnectedCallbackInfoInternal, DisconnectedCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnJoinRoomCallbackInternal))]
		internal static void OnJoinRoomCallbackInternalImplementation(System.IntPtr data)
		{
			OnJoinRoomCallback callback;
			JoinRoomCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnJoinRoomCallback, JoinRoomCallbackInfoInternal, JoinRoomCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLeaveRoomCallbackInternal))]
		internal static void OnLeaveRoomCallbackInternalImplementation(System.IntPtr data)
		{
			OnLeaveRoomCallback callback;
			LeaveRoomCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnLeaveRoomCallback, LeaveRoomCallbackInfoInternal, LeaveRoomCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnParticipantStatusChangedCallbackInternal))]
		internal static void OnParticipantStatusChangedCallbackInternalImplementation(System.IntPtr data)
		{
			OnParticipantStatusChangedCallback callback;
			ParticipantStatusChangedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnParticipantStatusChangedCallback, ParticipantStatusChangedCallbackInfoInternal, ParticipantStatusChangedCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}
	}
}