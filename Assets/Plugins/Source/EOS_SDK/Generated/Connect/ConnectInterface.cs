// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.Connect
{
	public sealed partial class ConnectInterface : Handle
	{
		public ConnectInterface()
		{
		}

		public ConnectInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyAuthExpiration" /> API.
		/// </summary>
		public const int AddnotifyauthexpirationApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLoginStatusChanged" /> API.
		/// </summary>
		public const int AddnotifyloginstatuschangedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserExternalAccountByAccountId" /> API.
		/// </summary>
		public const int CopyproductuserexternalaccountbyaccountidApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserExternalAccountByAccountType" /> API.
		/// </summary>
		public const int CopyproductuserexternalaccountbyaccounttypeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserExternalAccountByIndex" /> API.
		/// </summary>
		public const int CopyproductuserexternalaccountbyindexApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserInfo" /> API.
		/// </summary>
		public const int CopyproductuserinfoApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CreateDeviceId" /> API.
		/// </summary>
		public const int CreatedeviceidApiLatest = 1;

		/// <summary>
		/// Max length of a device model name, not including the terminating null
		/// </summary>
		public const int CreatedeviceidDevicemodelMaxLength = 64;

		/// <summary>
		/// The most recent version of the <see cref="CreateUser" /> API.
		/// </summary>
		public const int CreateuserApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="Credentials" /> struct.
		/// </summary>
		public const int CredentialsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="DeleteDeviceId" /> API.
		/// </summary>
		public const int DeletedeviceidApiLatest = 1;

		/// <summary>
		/// Max length of an external account ID in string form
		/// </summary>
		public const int ExternalAccountIdMaxLength = 256;

		/// <summary>
		/// The most recent version of the <see cref="ExternalAccountInfo" /> struct.
		/// </summary>
		public const int ExternalaccountinfoApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetExternalAccountMapping" /> API.
		/// </summary>
		public const int GetexternalaccountmappingApiLatest = 1;

		/// <summary>
		/// DEPRECATED! Use <see cref="GetexternalaccountmappingApiLatest" /> instead.
		/// </summary>
		public const int GetexternalaccountmappingsApiLatest = GetexternalaccountmappingApiLatest;

		/// <summary>
		/// The most recent version of the <see cref="GetProductUserExternalAccountCount" /> API.
		/// </summary>
		public const int GetproductuserexternalaccountcountApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetProductUserIdMapping" /> API.
		/// </summary>
		public const int GetproductuseridmappingApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="LinkAccount" /> API.
		/// </summary>
		public const int LinkaccountApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="Login" /> API.
		/// </summary>
		public const int LoginApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="OnAuthExpirationCallback" /> API.
		/// </summary>
		public const int OnauthexpirationcallbackApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="QueryExternalAccountMappings" /> API.
		/// </summary>
		public const int QueryexternalaccountmappingsApiLatest = 1;

		/// <summary>
		/// Maximum number of account IDs that can be queried at once
		/// </summary>
		public const int QueryexternalaccountmappingsMaxAccountIds = 128;

		/// <summary>
		/// The most recent version of the <see cref="QueryProductUserIdMappings" /> API.
		/// </summary>
		public const int QueryproductuseridmappingsApiLatest = 2;

		/// <summary>
		/// Timestamp value representing an undefined time for last login time.
		/// </summary>
		public const int TimeUndefined = -1;

		/// <summary>
		/// The most recent version of the <see cref="TransferDeviceIdAccount" /> API.
		/// </summary>
		public const int TransferdeviceidaccountApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UnlinkAccount" /> API.
		/// </summary>
		public const int UnlinkaccountApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UserLoginInfo" /> struct.
		/// </summary>
		public const int UserlogininfoApiLatest = 1;

		/// <summary>
		/// Max length of a display name, not including the terminating null.
		/// </summary>
		public const int UserlogininfoDisplaynameMaxLength = 32;

		/// <summary>
		/// Register to receive upcoming authentication expiration notifications.
		/// Notification is approximately 10 minutes prior to expiration.
		/// Call <see cref="Login" /> again with valid third party credentials to refresh access.
		/// 
		/// @note must call RemoveNotifyAuthExpiration to remove the notification.
		/// </summary>
		/// <param name="options">structure containing the API version of the callback to use.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the callback.</param>
		/// <param name="notification">a callback that is fired when the authentication is about to expire.</param>
		/// <returns>
		/// handle representing the registered callback.
		/// </returns>
		public ulong AddNotifyAuthExpiration(AddNotifyAuthExpirationOptions options, object clientData, OnAuthExpirationCallback notification)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyAuthExpirationOptionsInternal, AddNotifyAuthExpirationOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationInternal = new OnAuthExpirationCallbackInternal(OnAuthExpirationCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notification, notificationInternal);

			var funcResult = Bindings.EOS_Connect_AddNotifyAuthExpiration(InnerHandle, optionsAddress, clientDataAddress, notificationInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive user login status updates.
		/// @note must call RemoveNotifyLoginStatusChanged to remove the notification.
		/// </summary>
		/// <param name="options">structure containing the API version of the callback to use.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the callback.</param>
		/// <param name="notification">a callback that is fired when the login status for a user changes.</param>
		/// <returns>
		/// handle representing the registered callback.
		/// </returns>
		public ulong AddNotifyLoginStatusChanged(AddNotifyLoginStatusChangedOptions options, object clientData, OnLoginStatusChangedCallback notification)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyLoginStatusChangedOptionsInternal, AddNotifyLoginStatusChangedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationInternal = new OnLoginStatusChangedCallbackInternal(OnLoginStatusChangedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notification, notificationInternal);

			var funcResult = Bindings.EOS_Connect_AddNotifyLoginStatusChanged(InnerHandle, optionsAddress, clientDataAddress, notificationInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Fetch information about an external account linked to a Product User ID.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the target external account ID.</param>
		/// <param name="outExternalAccountInfo">The external account info data for the user with given external account ID.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo.
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo.
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter.
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet.
		/// </returns>
		public Result CopyProductUserExternalAccountByAccountId(CopyProductUserExternalAccountByAccountIdOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyProductUserExternalAccountByAccountIdOptionsInternal, CopyProductUserExternalAccountByAccountIdOptions>(ref optionsAddress, options);

			var outExternalAccountInfoAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Connect_CopyProductUserExternalAccountByAccountId(InnerHandle, optionsAddress, ref outExternalAccountInfoAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				Bindings.EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Fetch information about an external account of a specific type linked to a Product User ID.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the target external account type.</param>
		/// <param name="outExternalAccountInfo">The external account info data for the user with given external account type.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo.
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo.
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter.
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet.
		/// </returns>
		public Result CopyProductUserExternalAccountByAccountType(CopyProductUserExternalAccountByAccountTypeOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyProductUserExternalAccountByAccountTypeOptionsInternal, CopyProductUserExternalAccountByAccountTypeOptions>(ref optionsAddress, options);

			var outExternalAccountInfoAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Connect_CopyProductUserExternalAccountByAccountType(InnerHandle, optionsAddress, ref outExternalAccountInfoAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				Bindings.EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Fetch information about an external account linked to a Product User ID.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the target index.</param>
		/// <param name="outExternalAccountInfo">The external account info data for the user with given index.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo.
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo.
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter.
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet.
		/// </returns>
		public Result CopyProductUserExternalAccountByIndex(CopyProductUserExternalAccountByIndexOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyProductUserExternalAccountByIndexOptionsInternal, CopyProductUserExternalAccountByIndexOptions>(ref optionsAddress, options);

			var outExternalAccountInfoAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Connect_CopyProductUserExternalAccountByIndex(InnerHandle, optionsAddress, ref outExternalAccountInfoAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				Bindings.EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Fetch information about a Product User, using the external account that they most recently logged in with as the reference.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the target external account ID.</param>
		/// <param name="outExternalAccountInfo">The external account info data last logged in for the user.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo.
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo.
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter.
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet.
		/// </returns>
		public Result CopyProductUserInfo(CopyProductUserInfoOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyProductUserInfoOptionsInternal, CopyProductUserInfoOptions>(ref optionsAddress, options);

			var outExternalAccountInfoAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Connect_CopyProductUserInfo(InnerHandle, optionsAddress, ref outExternalAccountInfoAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				Bindings.EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Create a new unique pseudo-account that can be used to identify the current user profile on the local device.
		/// 
		/// This function is intended to be used by mobile games and PC games that wish to allow
		/// a new user to start playing without requiring to login to the game using any user identity.
		/// In addition to this, the Device ID feature is used to automatically login the local user
		/// also when they have linked at least one external user account(s) with the local Device ID.
		/// 
		/// It is possible to link many devices with the same user's account keyring using the Device ID feature.
		/// 
		/// Linking a device later or immediately with a real user account will ensure that the player
		/// will not lose their progress if they switch devices or lose the device at some point,
		/// as they will be always able to login with one of their linked real accounts and also link
		/// another new device with the user account associations keychain. Otherwise, without having
		/// at least one permanent user account linked to the Device ID, the player would lose all of their
		/// game data and progression permanently should something happen to their device or the local
		/// user profile on the device.
		/// 
		/// After a successful one-time CreateDeviceId operation, the game can login the local user
		/// automatically on subsequent game starts with <see cref="Login" /> using the <see cref="ExternalCredentialType.DeviceidAccessToken" />
		/// credentials type. If a Device ID already exists for the local user on the device then <see cref="Result.DuplicateNotAllowed" />
		/// error result is returned and the caller should proceed to calling <see cref="Login" /> directly.
		/// </summary>
		/// <param name="options">structure containing operation input parameters.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="completionDelegate">a callback that is fired when the create operation completes, either successfully or in error.</param>
		public void CreateDeviceId(CreateDeviceIdOptions options, object clientData, OnCreateDeviceIdCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CreateDeviceIdOptionsInternal, CreateDeviceIdOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnCreateDeviceIdCallbackInternal(OnCreateDeviceIdCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Connect_CreateDeviceId(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Create an account association with the Epic Online Service as a product user given their external auth credentials.
		/// </summary>
		/// <param name="options">structure containing a continuance token from a "user not found" response during Login (always try login first).</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="completionDelegate">a callback that is fired when the create operation completes, either successfully or in error.</param>
		public void CreateUser(CreateUserOptions options, object clientData, OnCreateUserCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CreateUserOptionsInternal, CreateUserOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnCreateUserCallbackInternal(OnCreateUserCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Connect_CreateUser(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Delete any existing Device ID access credentials for the current user profile on the local device.
		/// 
		/// The deletion is permanent and it is not possible to recover lost game data and progression
		/// if the Device ID had not been linked with at least one real external user account.
		/// </summary>
		/// <param name="options">structure containing operation input parameters</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the delete operation completes, either successfully or in error</param>
		public void DeleteDeviceId(DeleteDeviceIdOptions options, object clientData, OnDeleteDeviceIdCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<DeleteDeviceIdOptionsInternal, DeleteDeviceIdOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnDeleteDeviceIdCallbackInternal(OnDeleteDeviceIdCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Connect_DeleteDeviceId(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Fetch a Product User ID that maps to an external account ID cached from a previous query.
		/// </summary>
		/// <param name="options">structure containing the local user and target external account ID.</param>
		/// <returns>
		/// The Product User ID, previously retrieved from the backend service, for the given target external account.
		/// </returns>
		public ProductUserId GetExternalAccountMapping(GetExternalAccountMappingsOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetExternalAccountMappingsOptionsInternal, GetExternalAccountMappingsOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_Connect_GetExternalAccountMapping(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			ProductUserId funcResultReturn;
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch a Product User ID that is logged in. This Product User ID is in the Epic Online Services namespace.
		/// </summary>
		/// <param name="index">an index into the list of logged in users. If the index is out of bounds, the returned Product User ID will be invalid.</param>
		/// <returns>
		/// the Product User ID associated with the index passed.
		/// </returns>
		public ProductUserId GetLoggedInUserByIndex(int index)
		{
			var funcResult = Bindings.EOS_Connect_GetLoggedInUserByIndex(InnerHandle, index);

			ProductUserId funcResultReturn;
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch the number of product users that are logged in.
		/// </summary>
		/// <returns>
		/// the number of product users logged in.
		/// </returns>
		public int GetLoggedInUsersCount()
		{
			var funcResult = Bindings.EOS_Connect_GetLoggedInUsersCount(InnerHandle);

			return funcResult;
		}

		/// <summary>
		/// Fetches the login status for an Product User ID. This Product User ID is considered logged in as long as the underlying access token has not expired.
		/// </summary>
		/// <param name="localUserId">the Product User ID of the user being queried.</param>
		/// <returns>
		/// the enum value of a user's login status.
		/// </returns>
		public LoginStatus GetLoginStatus(ProductUserId localUserId)
		{
			var localUserIdInnerHandle = System.IntPtr.Zero;
			Helper.TryMarshalSet(ref localUserIdInnerHandle, localUserId);

			var funcResult = Bindings.EOS_Connect_GetLoginStatus(InnerHandle, localUserIdInnerHandle);

			return funcResult;
		}

		/// <summary>
		/// Fetch the number of linked external accounts for a Product User ID.
		/// <seealso cref="CopyProductUserExternalAccountByIndex" />
		/// </summary>
		/// <param name="options">The Options associated with retrieving the external account info count.</param>
		/// <returns>
		/// Number of external accounts or 0 otherwise.
		/// </returns>
		public uint GetProductUserExternalAccountCount(GetProductUserExternalAccountCountOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetProductUserExternalAccountCountOptionsInternal, GetProductUserExternalAccountCountOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_Connect_GetProductUserExternalAccountCount(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Fetch an external account ID, in string form, that maps to a given Product User ID.
		/// </summary>
		/// <param name="options">structure containing the local user and target Product User ID.</param>
		/// <param name="outBuffer">The buffer into which the external account ID data should be written. The buffer must be long enough to hold a string of <see cref="ExternalAccountIdMaxLength" />.</param>
		/// <param name="inOutBufferLength">
		/// The size of the OutBuffer in characters.
		/// The input buffer should include enough space to be null-terminated.
		/// When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
		/// </param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account ID was copied into the OutBuffer.
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserInfo.
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter.
		/// <see cref="Result.NotFound" /> if the mapping doesn't exist or hasn't been queried yet.
		/// <see cref="Result.LimitExceeded" /> if the OutBuffer is not large enough to receive the external account ID. InOutBufferLength contains the required minimum length to perform the operation successfully.
		/// </returns>
		public Result GetProductUserIdMapping(GetProductUserIdMappingOptions options, out string outBuffer)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetProductUserIdMappingOptionsInternal, GetProductUserIdMappingOptions>(ref optionsAddress, options);

			System.IntPtr outBufferAddress = System.IntPtr.Zero;
			int inOutBufferLength = ExternalAccountIdMaxLength + 1;
			Helper.TryMarshalAllocate(ref outBufferAddress, inOutBufferLength, out _);

			var funcResult = Bindings.EOS_Connect_GetProductUserIdMapping(InnerHandle, optionsAddress, outBufferAddress, ref inOutBufferLength);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outBufferAddress, out outBuffer);
			Helper.TryMarshalDispose(ref outBufferAddress);

			return funcResult;
		}

		/// <summary>
		/// Link a set of external auth credentials with an existing product user on the Epic Online Service.
		/// </summary>
		/// <param name="options">structure containing a continuance token from a "user not found" response during Login (always try login first) and a currently logged in user not already associated with this external auth provider.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="completionDelegate">a callback that is fired when the link operation completes, either successfully or in error.</param>
		public void LinkAccount(LinkAccountOptions options, object clientData, OnLinkAccountCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<LinkAccountOptionsInternal, LinkAccountOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnLinkAccountCallbackInternal(OnLinkAccountCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Connect_LinkAccount(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Login/Authenticate given a valid set of external auth credentials.
		/// </summary>
		/// <param name="options">structure containing the external account credentials and type to use during the login operation.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="completionDelegate">a callback that is fired when the login operation completes, either successfully or in error.</param>
		public void Login(LoginOptions options, object clientData, OnLoginCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<LoginOptionsInternal, LoginOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnLoginCallbackInternal(OnLoginCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Connect_Login(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Retrieve the equivalent Product User IDs from a list of external account IDs from supported account providers.
		/// The values will be cached and retrievable through <see cref="GetExternalAccountMapping" />.
		/// </summary>
		/// <param name="options">structure containing a list of external account IDs, in string form, to query for the Product User ID representation.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="completionDelegate">a callback that is fired when the query operation completes, either successfully or in error.</param>
		public void QueryExternalAccountMappings(QueryExternalAccountMappingsOptions options, object clientData, OnQueryExternalAccountMappingsCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<QueryExternalAccountMappingsOptionsInternal, QueryExternalAccountMappingsOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnQueryExternalAccountMappingsCallbackInternal(OnQueryExternalAccountMappingsCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Connect_QueryExternalAccountMappings(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Retrieve the equivalent external account mappings from a list of Product User IDs.
		/// This will include data for each external account info found for the linked product IDs.
		/// 
		/// The values will be cached and retrievable via <see cref="GetProductUserIdMapping" />, <see cref="CopyProductUserExternalAccountByIndex" />,
		/// <see cref="CopyProductUserExternalAccountByAccountType" /> or <see cref="CopyProductUserExternalAccountByAccountId" />.
		/// <seealso cref="ExternalAccountInfo" />
		/// <seealso cref="GetProductUserExternalAccountCount" />
		/// <seealso cref="GetProductUserIdMapping" />
		/// <seealso cref="CopyProductUserExternalAccountByIndex" />
		/// <seealso cref="CopyProductUserExternalAccountByAccountType" />
		/// <seealso cref="CopyProductUserExternalAccountByAccountId" />
		/// <seealso cref="CopyProductUserInfo" />
		/// </summary>
		/// <param name="options">structure containing a list of Product User IDs to query for the external account representation.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="completionDelegate">a callback that is fired when the query operation completes, either successfully or in error.</param>
		public void QueryProductUserIdMappings(QueryProductUserIdMappingsOptions options, object clientData, OnQueryProductUserIdMappingsCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<QueryProductUserIdMappingsOptionsInternal, QueryProductUserIdMappingsOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnQueryProductUserIdMappingsCallbackInternal(OnQueryProductUserIdMappingsCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Connect_QueryProductUserIdMappings(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Unregister from receiving expiration notifications.
		/// </summary>
		/// <param name="inId">handle representing the registered callback.</param>
		public void RemoveNotifyAuthExpiration(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);

			Bindings.EOS_Connect_RemoveNotifyAuthExpiration(InnerHandle, inId);
		}

		/// <summary>
		/// Unregister from receiving user login status updates.
		/// </summary>
		/// <param name="inId">handle representing the registered callback.</param>
		public void RemoveNotifyLoginStatusChanged(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);

			Bindings.EOS_Connect_RemoveNotifyLoginStatusChanged(InnerHandle, inId);
		}

		/// <summary>
		/// Transfer a Device ID pseudo-account and the product user associated with it into another
		/// keychain linked with real user accounts (such as Epic Games, PlayStation(TM)Network, Xbox Live, and other).
		/// 
		/// This function allows transferring a product user, i.e. the local user's game progression
		/// backend data from a Device ID owned keychain into a keychain with real user accounts
		/// linked to it. The transfer of Device ID owned product user into a keychain of real user
		/// accounts allows persisting the user's game data on the backend in the event that they
		/// would lose access to the local device or otherwise switch to another device or platform.
		/// 
		/// This function is only applicable in the situation of where the local user first plays
		/// the game using the anonymous Device ID login, then later logs in using a real user
		/// account that they have also already used to play the same game or another game under the
		/// same organization within Epic Online Services. In such situation, while normally the login
		/// attempt with a real user account would return <see cref="Result.InvalidUser" /> and an <see cref="ContinuanceToken" />
		/// and allow calling the <see cref="LinkAccount" /> API to link it with the Device ID's keychain,
		/// instead the login operation succeeds and finds an existing user because the association
		/// already exists. Because the user cannot have two product users simultaneously to play with,
		/// the game should prompt the user to choose which profile to keep and which one to discard
		/// permanently. Based on the user choice, the game may then proceed to transfer the Device ID
		/// login into the keychain that is persistent and backed by real user accounts, and if the user
		/// chooses so, move the product user as well into the destination keychain and overwrite the
		/// existing previous product user with it. To clarify, moving the product user with the Device ID
		/// login in this way into a persisted keychain allows to preserve the so far only locally persisted
		/// game progression and thus protect the user against a case where they lose access to the device.
		/// 
		/// On success, the completion callback will return the preserved <see cref="ProductUserId" /> that remains
		/// logged in while the discarded <see cref="ProductUserId" /> has been invalidated and deleted permanently.
		/// Consecutive logins using the existing Device ID login type or the external account will
		/// connect the user to the same backend data belonging to the preserved <see cref="ProductUserId" />.
		/// 
		/// Example walkthrough: Cross-platform mobile game using the anonymous Device ID login.
		/// 
		/// For onboarding new users, the game will attempt to always automatically login the local user
		/// by calling <see cref="Login" /> using the <see cref="ExternalCredentialType.DeviceidAccessToken" /> login type. If the local
		/// Device ID credentials are not found, and the game wants a frictionless entry for the first time
		/// user experience, the game will automatically call <see cref="CreateDeviceId" /> to create new
		/// Device ID pseudo-account and then login the local user into it. Consecutive game starts will
		/// thus automatically login the user to their locally persisted Device ID account.
		/// 
		/// The user starts playing anonymously using the Device ID login type and makes significant game progress.
		/// Later, they login using an external account that they have already used previously for the
		/// same game perhaps on another platform, or another game owned by the same organization.
		/// In such case, <see cref="Login" /> will automatically login the user to their existing account
		/// linking keychain and create automatically a new empty product user for this product.
		/// 
		/// In order for the user to use their existing previously created keychain and have the locally
		/// created Device ID login reference to that keychain instead, the user's current product user
		/// needs to be moved to be under that keychain so that their existing game progression will be
		/// preserved. To do so, the game can call <see cref="TransferDeviceIdAccount" /> to transfer the
		/// Device ID login and the product user associated with it into the other keychain that has real
		/// external user account(s) linked to it. Note that it is important that the game either automatically
		/// checks that the other product user does not have any meaningful progression data, or otherwise
		/// will prompt the user to make the choice on which game progression to preserve and which can
		/// be discarded permanently. The other product user will be discarded permanently and cannot be
		/// recovered, so it is very important that the user is guided to make the right choice to avoid
		/// accidental loss of all game progression.
		/// <seealso cref="Login" />
		/// <seealso cref="CreateDeviceId" />
		/// </summary>
		/// <param name="options">structure containing the logged in product users and specifying which one will be preserved.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="completionDelegate">a callback that is fired when the transfer operation completes, either successfully or in error.</param>
		public void TransferDeviceIdAccount(TransferDeviceIdAccountOptions options, object clientData, OnTransferDeviceIdAccountCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<TransferDeviceIdAccountOptionsInternal, TransferDeviceIdAccountOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnTransferDeviceIdAccountCallbackInternal(OnTransferDeviceIdAccountCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Connect_TransferDeviceIdAccount(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Unlink external auth credentials from the owning keychain of a logged in product user.
		/// 
		/// This function allows recovering the user from scenarios where they have accidentally proceeded to creating
		/// a new product user for the local native user account, instead of linking it with an existing keychain that
		/// they have previously created by playing the game (or another game owned by the organization) on another platform.
		/// 
		/// In such scenario, after the initial platform login and a new product user creation, the user wishes to re-login
		/// using other set of external auth credentials to connect with their existing game progression data. In order to
		/// allow automatic login also on the current platform, they will need to unlink the accidentally created new keychain
		/// and product user and then use the <see cref="Login" /> and <see cref="LinkAccount" /> APIs to link the local native platform
		/// account with that previously created existing product user and its owning keychain.
		/// 
		/// In another scenario, the user may simply want to disassociate the account that they have logged in with from the current
		/// keychain that it is linked with, perhaps to link it against another keychain or to separate the game progressions again.
		/// 
		/// In order to protect against account theft, it is only possible to unlink user accounts that have been authenticated
		/// and logged in to the product user in the current session. This prevents a malicious actor from gaining access to one
		/// of the linked accounts and using it to remove all other accounts linked with the keychain. This also prevents a malicious
		/// actor from replacing the unlinked account with their own corresponding account on the same platform, as the unlinking
		/// operation will ensure that any existing authentication session cannot be used to re-link and overwrite the entry without
		/// authenticating with one of the other linked accounts in the keychain. These restrictions limit the potential attack surface
		/// related to account theft scenarios.
		/// </summary>
		/// <param name="options">structure containing operation input parameters.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="completionDelegate">a callback that is fired when the unlink operation completes, either successfully or in error.</param>
		public void UnlinkAccount(UnlinkAccountOptions options, object clientData, OnUnlinkAccountCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<UnlinkAccountOptionsInternal, UnlinkAccountOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnUnlinkAccountCallbackInternal(OnUnlinkAccountCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Connect_UnlinkAccount(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		[MonoPInvokeCallback(typeof(OnAuthExpirationCallbackInternal))]
		internal static void OnAuthExpirationCallbackInternalImplementation(System.IntPtr data)
		{
			OnAuthExpirationCallback callback;
			AuthExpirationCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnAuthExpirationCallback, AuthExpirationCallbackInfoInternal, AuthExpirationCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnCreateDeviceIdCallbackInternal))]
		internal static void OnCreateDeviceIdCallbackInternalImplementation(System.IntPtr data)
		{
			OnCreateDeviceIdCallback callback;
			CreateDeviceIdCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnCreateDeviceIdCallback, CreateDeviceIdCallbackInfoInternal, CreateDeviceIdCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnCreateUserCallbackInternal))]
		internal static void OnCreateUserCallbackInternalImplementation(System.IntPtr data)
		{
			OnCreateUserCallback callback;
			CreateUserCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnCreateUserCallback, CreateUserCallbackInfoInternal, CreateUserCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnDeleteDeviceIdCallbackInternal))]
		internal static void OnDeleteDeviceIdCallbackInternalImplementation(System.IntPtr data)
		{
			OnDeleteDeviceIdCallback callback;
			DeleteDeviceIdCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnDeleteDeviceIdCallback, DeleteDeviceIdCallbackInfoInternal, DeleteDeviceIdCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLinkAccountCallbackInternal))]
		internal static void OnLinkAccountCallbackInternalImplementation(System.IntPtr data)
		{
			OnLinkAccountCallback callback;
			LinkAccountCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnLinkAccountCallback, LinkAccountCallbackInfoInternal, LinkAccountCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLoginCallbackInternal))]
		internal static void OnLoginCallbackInternalImplementation(System.IntPtr data)
		{
			OnLoginCallback callback;
			LoginCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnLoginCallback, LoginCallbackInfoInternal, LoginCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLoginStatusChangedCallbackInternal))]
		internal static void OnLoginStatusChangedCallbackInternalImplementation(System.IntPtr data)
		{
			OnLoginStatusChangedCallback callback;
			LoginStatusChangedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnLoginStatusChangedCallback, LoginStatusChangedCallbackInfoInternal, LoginStatusChangedCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnQueryExternalAccountMappingsCallbackInternal))]
		internal static void OnQueryExternalAccountMappingsCallbackInternalImplementation(System.IntPtr data)
		{
			OnQueryExternalAccountMappingsCallback callback;
			QueryExternalAccountMappingsCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnQueryExternalAccountMappingsCallback, QueryExternalAccountMappingsCallbackInfoInternal, QueryExternalAccountMappingsCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnQueryProductUserIdMappingsCallbackInternal))]
		internal static void OnQueryProductUserIdMappingsCallbackInternalImplementation(System.IntPtr data)
		{
			OnQueryProductUserIdMappingsCallback callback;
			QueryProductUserIdMappingsCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnQueryProductUserIdMappingsCallback, QueryProductUserIdMappingsCallbackInfoInternal, QueryProductUserIdMappingsCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnTransferDeviceIdAccountCallbackInternal))]
		internal static void OnTransferDeviceIdAccountCallbackInternalImplementation(System.IntPtr data)
		{
			OnTransferDeviceIdAccountCallback callback;
			TransferDeviceIdAccountCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnTransferDeviceIdAccountCallback, TransferDeviceIdAccountCallbackInfoInternal, TransferDeviceIdAccountCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnUnlinkAccountCallbackInternal))]
		internal static void OnUnlinkAccountCallbackInternalImplementation(System.IntPtr data)
		{
			OnUnlinkAccountCallback callback;
			UnlinkAccountCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnUnlinkAccountCallback, UnlinkAccountCallbackInfoInternal, UnlinkAccountCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}
	}
}