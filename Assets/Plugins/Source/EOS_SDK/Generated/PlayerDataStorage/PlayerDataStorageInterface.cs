// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.PlayerDataStorage
{
	public sealed partial class PlayerDataStorageInterface : Handle
	{
		public PlayerDataStorageInterface()
		{
		}

		public PlayerDataStorageInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		public const int CopyfilemetadataatindexoptionsApiLatest = 1;

		public const int CopyfilemetadatabyfilenameoptionsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="DeleteCacheOptions" /> API.
		/// </summary>
		public const int DeletecacheoptionsApiLatest = 1;

		public const int DeletefileoptionsApiLatest = 1;

		public const int DuplicatefileoptionsApiLatest = 1;

		/// <summary>
		/// Maximum File size in bytes
		/// </summary>
		public const int FileMaxSizeBytes = (64 * 1024 * 1024);

		public const int FilemetadataApiLatest = 3;

		/// <summary>
		/// Maximum File Name Length in bytes
		/// </summary>
		public const int FilenameMaxLengthBytes = 64;

		public const int GetfilemetadatacountoptionsApiLatest = 1;

		public const int QueryfilelistoptionsApiLatest = 1;

		public const int QueryfileoptionsApiLatest = 1;

		public const int ReadfileoptionsApiLatest = 1;

		public const int WritefileoptionsApiLatest = 1;

		/// <summary>
		/// Get the cached copy of a file's metadata by index. The metadata will be for the last retrieved or successfully saved version, and will not include any local changes that have not been
		/// committed by calling SaveFile. The returned pointer must be released by the user when no longer needed.
		/// <seealso cref="GetFileMetadataCount" />
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="copyFileMetadataOptions">Object containing properties related to which user is requesting metadata, and at what index</param>
		/// <param name="outMetadata">A copy of the FileMetadata structure will be set if successful. This data must be released by calling <see cref="Release" />.</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> if the requested metadata is currently cached, otherwise an error result explaining what went wrong
		/// </returns>
		public Result CopyFileMetadataAtIndex(CopyFileMetadataAtIndexOptions copyFileMetadataOptions, out FileMetadata outMetadata)
		{
			var copyFileMetadataOptionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyFileMetadataAtIndexOptionsInternal, CopyFileMetadataAtIndexOptions>(ref copyFileMetadataOptionsAddress, copyFileMetadataOptions);

			var outMetadataAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_PlayerDataStorage_CopyFileMetadataAtIndex(InnerHandle, copyFileMetadataOptionsAddress, ref outMetadataAddress);

			Helper.TryMarshalDispose(ref copyFileMetadataOptionsAddress);

			if (Helper.TryMarshalGet<FileMetadataInternal, FileMetadata>(outMetadataAddress, out outMetadata))
			{
				Bindings.EOS_PlayerDataStorage_FileMetadata_Release(outMetadataAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Create the cached copy of a file's metadata by filename. The metadata will be for the last retrieved or successfully saved version, and will not include any changes that have not
		/// completed writing. The returned pointer must be released by the user when no longer needed.
		/// </summary>
		/// <param name="copyFileMetadataOptions">Object containing properties related to which user is requesting metadata, and for which filename</param>
		/// <param name="outMetadata">A copy of the FileMetadata structure will be set if successful. This data must be released by calling <see cref="Release" />.</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> if the metadata is currently cached, otherwise an error result explaining what went wrong
		/// </returns>
		public Result CopyFileMetadataByFilename(CopyFileMetadataByFilenameOptions copyFileMetadataOptions, out FileMetadata outMetadata)
		{
			var copyFileMetadataOptionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyFileMetadataByFilenameOptionsInternal, CopyFileMetadataByFilenameOptions>(ref copyFileMetadataOptionsAddress, copyFileMetadataOptions);

			var outMetadataAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_PlayerDataStorage_CopyFileMetadataByFilename(InnerHandle, copyFileMetadataOptionsAddress, ref outMetadataAddress);

			Helper.TryMarshalDispose(ref copyFileMetadataOptionsAddress);

			if (Helper.TryMarshalGet<FileMetadataInternal, FileMetadata>(outMetadataAddress, out outMetadata))
			{
				Bindings.EOS_PlayerDataStorage_FileMetadata_Release(outMetadataAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Clear previously cached file data. This operation will be done asynchronously. All cached files except those corresponding to the transfers in progress will be removed.
		/// Warning: Use this with care. Cache system generally tries to clear old and unused cached files from time to time. Unnecessarily clearing cache can degrade performance as SDK will have to re-download data.
		/// </summary>
		/// <param name="options">Object containing properties related to which user is deleting cache</param>
		/// <param name="clientData">Optional pointer to help clients track this request, that is returned in associated callbacks</param>
		/// <param name="completionCallback">This function is called when the delete cache operation completes</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation was started correctly, otherwise an error result explaining what went wrong
		/// </returns>
		public Result DeleteCache(DeleteCacheOptions options, object clientData, OnDeleteCacheCompleteCallback completionCallback)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<DeleteCacheOptionsInternal, DeleteCacheOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionCallbackInternal = new OnDeleteCacheCompleteCallbackInternal(OnDeleteCacheCompleteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionCallback, completionCallbackInternal);

			var funcResult = Bindings.EOS_PlayerDataStorage_DeleteCache(InnerHandle, optionsAddress, clientDataAddress, completionCallbackInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Deletes an existing file in the cloud. If successful, the file's data will be removed from our local cache.
		/// </summary>
		/// <param name="deleteOptions">Object containing properties related to which user is deleting the file, and what file name is</param>
		/// <param name="clientData">Optional pointer to help clients track this request, that is returned in the completion callback</param>
		/// <param name="completionCallback">This function is called when the delete operation completes</param>
		public void DeleteFile(DeleteFileOptions deleteOptions, object clientData, OnDeleteFileCompleteCallback completionCallback)
		{
			var deleteOptionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<DeleteFileOptionsInternal, DeleteFileOptions>(ref deleteOptionsAddress, deleteOptions);

			var clientDataAddress = System.IntPtr.Zero;

			var completionCallbackInternal = new OnDeleteFileCompleteCallbackInternal(OnDeleteFileCompleteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionCallback, completionCallbackInternal);

			Bindings.EOS_PlayerDataStorage_DeleteFile(InnerHandle, deleteOptionsAddress, clientDataAddress, completionCallbackInternal);

			Helper.TryMarshalDispose(ref deleteOptionsAddress);
		}

		/// <summary>
		/// Copies the data of an existing file to a new filename. This action happens entirely on the server and will not upload the contents of the source destination file from the host. This
		/// function paired with a subsequent <see cref="DeleteFile" /> can be used to rename a file. If successful, the destination file's metadata will be updated in our local cache.
		/// </summary>
		/// <param name="duplicateOptions">Object containing properties related to which user is duplicating the file, and what the source and destination file names are</param>
		/// <param name="clientData">Optional pointer to help clients track this request, that is returned in the completion callback</param>
		/// <param name="completionCallback">This function is called when the duplicate operation completes</param>
		public void DuplicateFile(DuplicateFileOptions duplicateOptions, object clientData, OnDuplicateFileCompleteCallback completionCallback)
		{
			var duplicateOptionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<DuplicateFileOptionsInternal, DuplicateFileOptions>(ref duplicateOptionsAddress, duplicateOptions);

			var clientDataAddress = System.IntPtr.Zero;

			var completionCallbackInternal = new OnDuplicateFileCompleteCallbackInternal(OnDuplicateFileCompleteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionCallback, completionCallbackInternal);

			Bindings.EOS_PlayerDataStorage_DuplicateFile(InnerHandle, duplicateOptionsAddress, clientDataAddress, completionCallbackInternal);

			Helper.TryMarshalDispose(ref duplicateOptionsAddress);
		}

		/// <summary>
		/// Get the count of files we have previously queried information for and files we have previously read from / written to.
		/// <seealso cref="CopyFileMetadataAtIndex" />
		/// </summary>
		/// <param name="getFileMetadataCountOptions">Object containing properties related to which user is requesting the metadata count</param>
		/// <param name="outFileMetadataCount">If successful, the count of metadata currently cached</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> if the input was valid, otherwise an error result explaining what went wrong
		/// </returns>
		public Result GetFileMetadataCount(GetFileMetadataCountOptions getFileMetadataCountOptions, out int outFileMetadataCount)
		{
			var getFileMetadataCountOptionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetFileMetadataCountOptionsInternal, GetFileMetadataCountOptions>(ref getFileMetadataCountOptionsAddress, getFileMetadataCountOptions);

			outFileMetadataCount = Helper.GetDefault<int>();

			var funcResult = Bindings.EOS_PlayerDataStorage_GetFileMetadataCount(InnerHandle, getFileMetadataCountOptionsAddress, ref outFileMetadataCount);

			Helper.TryMarshalDispose(ref getFileMetadataCountOptionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Query a specific file's metadata, such as file names, size, and a MD5 hash of the data. This is not required before a file may be opened, saved, copied, or deleted. Once a file has
		/// been queried, its metadata will be available by the <see cref="CopyFileMetadataAtIndex" /> and <see cref="CopyFileMetadataByFilename" /> functions.
		/// <seealso cref="GetFileMetadataCount" />
		/// <seealso cref="CopyFileMetadataAtIndex" />
		/// <seealso cref="CopyFileMetadataByFilename" />
		/// </summary>
		/// <param name="queryFileOptions">Object containing properties related to which user is querying files, and what file is being queried</param>
		/// <param name="clientData">Optional pointer to help clients track this request, that is returned in the completion callback</param>
		/// <param name="completionCallback">This function is called when the query operation completes</param>
		public void QueryFile(QueryFileOptions queryFileOptions, object clientData, OnQueryFileCompleteCallback completionCallback)
		{
			var queryFileOptionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<QueryFileOptionsInternal, QueryFileOptions>(ref queryFileOptionsAddress, queryFileOptions);

			var clientDataAddress = System.IntPtr.Zero;

			var completionCallbackInternal = new OnQueryFileCompleteCallbackInternal(OnQueryFileCompleteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionCallback, completionCallbackInternal);

			Bindings.EOS_PlayerDataStorage_QueryFile(InnerHandle, queryFileOptionsAddress, clientDataAddress, completionCallbackInternal);

			Helper.TryMarshalDispose(ref queryFileOptionsAddress);
		}

		/// <summary>
		/// Query the file metadata, such as file names, size, and a MD5 hash of the data, for all files owned by this user for this application. This is not required before a file may be opened,
		/// saved, copied, or deleted.
		/// <seealso cref="GetFileMetadataCount" />
		/// <seealso cref="CopyFileMetadataAtIndex" />
		/// <seealso cref="CopyFileMetadataByFilename" />
		/// </summary>
		/// <param name="queryFileListOptions">Object containing properties related to which user is querying files</param>
		/// <param name="clientData">Optional pointer to help clients track this request, that is returned in the completion callback</param>
		/// <param name="completionCallback">This function is called when the query operation completes</param>
		public void QueryFileList(QueryFileListOptions queryFileListOptions, object clientData, OnQueryFileListCompleteCallback completionCallback)
		{
			var queryFileListOptionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<QueryFileListOptionsInternal, QueryFileListOptions>(ref queryFileListOptionsAddress, queryFileListOptions);

			var clientDataAddress = System.IntPtr.Zero;

			var completionCallbackInternal = new OnQueryFileListCompleteCallbackInternal(OnQueryFileListCompleteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionCallback, completionCallbackInternal);

			Bindings.EOS_PlayerDataStorage_QueryFileList(InnerHandle, queryFileListOptionsAddress, clientDataAddress, completionCallbackInternal);

			Helper.TryMarshalDispose(ref queryFileListOptionsAddress);
		}

		/// <summary>
		/// Retrieve the contents of a specific file, potentially downloading the contents if we do not have a local copy, from the cloud. This request will occur asynchronously, potentially over
		/// multiple frames. All callbacks for this function will come from the same thread that the SDK is ticked from. If specified, the FileTransferProgressCallback will always be called at
		/// least once if the request is started successfully.
		/// <seealso cref="PlayerDataStorageFileTransferRequest.Release" />
		/// </summary>
		/// <param name="readOptions">Object containing properties related to which user is opening the file, what the file's name is, and related mechanisms for copying the data</param>
		/// <param name="clientData">Optional pointer to help clients track this request, that is returned in associated callbacks</param>
		/// <param name="completionCallback">This function is called when the read operation completes</param>
		/// <returns>
		/// A valid Player Data Storage File Request handle if successful, or NULL otherwise. Data contained in the completion callback will have more detailed information about issues with the request in failure cases. This handle must be released when it is no longer needed
		/// </returns>
		public PlayerDataStorageFileTransferRequest ReadFile(ReadFileOptions readOptions, object clientData, OnReadFileCompleteCallback completionCallback)
		{
			var readOptionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<ReadFileOptionsInternal, ReadFileOptions>(ref readOptionsAddress, readOptions);

			var clientDataAddress = System.IntPtr.Zero;

			var completionCallbackInternal = new OnReadFileCompleteCallbackInternal(OnReadFileCompleteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionCallback, completionCallbackInternal, readOptions.ReadFileDataCallback, ReadFileOptionsInternal.ReadFileDataCallback, readOptions.FileTransferProgressCallback, ReadFileOptionsInternal.FileTransferProgressCallback);

			var funcResult = Bindings.EOS_PlayerDataStorage_ReadFile(InnerHandle, readOptionsAddress, clientDataAddress, completionCallbackInternal);

			Helper.TryMarshalDispose(ref readOptionsAddress);

			PlayerDataStorageFileTransferRequest funcResultReturn;
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Write new data to a specific file, potentially overwriting any existing file by the same name, to the cloud. This request will occur asynchronously, potentially over multiple frames.
		/// All callbacks for this function will come from the same thread that the SDK is ticked from. If specified, the FileTransferProgressCallback will always be called at least once if the
		/// request is started successfully.
		/// <seealso cref="PlayerDataStorageFileTransferRequest.Release" />
		/// </summary>
		/// <param name="writeOptions">Object containing properties related to which user is writing the file, what the file's name is, and related mechanisms for writing the data</param>
		/// <param name="clientData">Optional pointer to help clients track this request, that is returned in associated callbacks</param>
		/// <param name="completionCallback">This function is called when the write operation completes</param>
		/// <returns>
		/// A valid Player Data Storage File Request handle if successful, or NULL otherwise. Data contained in the completion callback will have more detailed information about issues with the request in failure cases. This handle must be released when it is no longer needed
		/// </returns>
		public PlayerDataStorageFileTransferRequest WriteFile(WriteFileOptions writeOptions, object clientData, OnWriteFileCompleteCallback completionCallback)
		{
			var writeOptionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<WriteFileOptionsInternal, WriteFileOptions>(ref writeOptionsAddress, writeOptions);

			var clientDataAddress = System.IntPtr.Zero;

			var completionCallbackInternal = new OnWriteFileCompleteCallbackInternal(OnWriteFileCompleteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionCallback, completionCallbackInternal, writeOptions.WriteFileDataCallback, WriteFileOptionsInternal.WriteFileDataCallback, writeOptions.FileTransferProgressCallback, WriteFileOptionsInternal.FileTransferProgressCallback);

			var funcResult = Bindings.EOS_PlayerDataStorage_WriteFile(InnerHandle, writeOptionsAddress, clientDataAddress, completionCallbackInternal);

			Helper.TryMarshalDispose(ref writeOptionsAddress);

			PlayerDataStorageFileTransferRequest funcResultReturn;
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		[MonoPInvokeCallback(typeof(OnDeleteCacheCompleteCallbackInternal))]
		internal static void OnDeleteCacheCompleteCallbackInternalImplementation(System.IntPtr data)
		{
			OnDeleteCacheCompleteCallback callback;
			DeleteCacheCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnDeleteCacheCompleteCallback, DeleteCacheCallbackInfoInternal, DeleteCacheCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnDeleteFileCompleteCallbackInternal))]
		internal static void OnDeleteFileCompleteCallbackInternalImplementation(System.IntPtr data)
		{
			OnDeleteFileCompleteCallback callback;
			DeleteFileCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnDeleteFileCompleteCallback, DeleteFileCallbackInfoInternal, DeleteFileCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnDuplicateFileCompleteCallbackInternal))]
		internal static void OnDuplicateFileCompleteCallbackInternalImplementation(System.IntPtr data)
		{
			OnDuplicateFileCompleteCallback callback;
			DuplicateFileCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnDuplicateFileCompleteCallback, DuplicateFileCallbackInfoInternal, DuplicateFileCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnFileTransferProgressCallbackInternal))]
		internal static void OnFileTransferProgressCallbackInternalImplementation(System.IntPtr data)
		{
			OnFileTransferProgressCallback callback;
			FileTransferProgressCallbackInfo callbackInfo;
			if (Helper.TryGetStructCallback<OnFileTransferProgressCallback, FileTransferProgressCallbackInfoInternal, FileTransferProgressCallbackInfo>(data, out callback, out callbackInfo))
			{
				FileTransferProgressCallbackInfo dataObj;
				Helper.TryMarshalGet<FileTransferProgressCallbackInfoInternal, FileTransferProgressCallbackInfo>(data, out dataObj);

				callback(dataObj);
			}
		}

		[MonoPInvokeCallback(typeof(OnQueryFileCompleteCallbackInternal))]
		internal static void OnQueryFileCompleteCallbackInternalImplementation(System.IntPtr data)
		{
			OnQueryFileCompleteCallback callback;
			QueryFileCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnQueryFileCompleteCallback, QueryFileCallbackInfoInternal, QueryFileCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnQueryFileListCompleteCallbackInternal))]
		internal static void OnQueryFileListCompleteCallbackInternalImplementation(System.IntPtr data)
		{
			OnQueryFileListCompleteCallback callback;
			QueryFileListCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnQueryFileListCompleteCallback, QueryFileListCallbackInfoInternal, QueryFileListCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnReadFileCompleteCallbackInternal))]
		internal static void OnReadFileCompleteCallbackInternalImplementation(System.IntPtr data)
		{
			OnReadFileCompleteCallback callback;
			ReadFileCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnReadFileCompleteCallback, ReadFileCallbackInfoInternal, ReadFileCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnReadFileDataCallbackInternal))]
		internal static ReadResult OnReadFileDataCallbackInternalImplementation(System.IntPtr data)
		{
			OnReadFileDataCallback callback;
			ReadFileDataCallbackInfo callbackInfo;
			if (Helper.TryGetStructCallback<OnReadFileDataCallback, ReadFileDataCallbackInfoInternal, ReadFileDataCallbackInfo>(data, out callback, out callbackInfo))
			{
				ReadFileDataCallbackInfo dataObj;
				Helper.TryMarshalGet<ReadFileDataCallbackInfoInternal, ReadFileDataCallbackInfo>(data, out dataObj);

				var funcResult = callback(dataObj);

				return funcResult;
			}

			return Helper.GetDefault<ReadResult>();
		}

		[MonoPInvokeCallback(typeof(OnWriteFileCompleteCallbackInternal))]
		internal static void OnWriteFileCompleteCallbackInternalImplementation(System.IntPtr data)
		{
			OnWriteFileCompleteCallback callback;
			WriteFileCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnWriteFileCompleteCallback, WriteFileCallbackInfoInternal, WriteFileCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnWriteFileDataCallbackInternal))]
		internal static WriteResult OnWriteFileDataCallbackInternalImplementation(System.IntPtr data, System.IntPtr outDataBuffer, ref uint outDataWritten)
		{
			OnWriteFileDataCallback callback;
			WriteFileDataCallbackInfo callbackInfo;
			if (Helper.TryGetStructCallback<OnWriteFileDataCallback, WriteFileDataCallbackInfoInternal, WriteFileDataCallbackInfo>(data, out callback, out callbackInfo))
			{
				WriteFileDataCallbackInfo dataObj;
				Helper.TryMarshalGet<WriteFileDataCallbackInfoInternal, WriteFileDataCallbackInfo>(data, out dataObj);

				byte[] outDataBufferArray;

				var funcResult = callback(dataObj, out outDataBufferArray);

				Helper.TryMarshalGet(outDataBufferArray, out outDataWritten);
				Helper.TryMarshalCopy(outDataBuffer, outDataBufferArray);

				return funcResult;
			}

			return Helper.GetDefault<WriteResult>();
		}
	}
}