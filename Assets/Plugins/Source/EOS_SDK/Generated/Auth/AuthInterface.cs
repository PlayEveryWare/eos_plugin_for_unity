// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.Auth
{
	public sealed partial class AuthInterface : Handle
	{
		public AuthInterface()
		{
		}

		public AuthInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="AccountFeatureRestrictedInfo" /> struct.
		/// </summary>
		public const int AccountfeaturerestrictedinfoApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLoginStatusChanged" /> API.
		/// </summary>
		public const int AddnotifyloginstatuschangedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyIdToken" /> API.
		/// </summary>
		public const int CopyidtokenApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyUserAuthToken" /> API.
		/// </summary>
		public const int CopyuserauthtokenApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="Credentials" /> struct.
		/// </summary>
		public const int CredentialsApiLatest = 4;

		/// <summary>
		/// The most recent version of the <see cref="DeletePersistentAuth" /> API.
		/// </summary>
		public const int DeletepersistentauthApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="IdToken" /> struct.
		/// </summary>
		public const int IdtokenApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="LinkAccount" /> API.
		/// </summary>
		public const int LinkaccountApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="Login" /> API.
		/// </summary>
		public const int LoginApiLatest = 3;

		/// <summary>
		/// The most recent version of the <see cref="Logout" /> API.
		/// </summary>
		public const int LogoutApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="PinGrantInfo" /> struct.
		/// </summary>
		public const int PingrantinfoApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="QueryIdToken" /> API.
		/// </summary>
		public const int QueryidtokenApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="Token" /> struct.
		/// </summary>
		public const int TokenApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="VerifyIdToken" /> API.
		/// </summary>
		public const int VerifyidtokenApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="VerifyUserAuth" /> API.
		/// </summary>
		public const int VerifyuserauthApiLatest = 1;

		/// <summary>
		/// Register to receive login status updates.
		/// must call RemoveNotifyLoginStatusChanged to remove the notification
		/// </summary>
		/// <param name="options">structure containing the api version of AddNotifyLoginStatusChanged to use</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the callback</param>
		/// <param name="notification">a callback that is fired when the login status for a user changes</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLoginStatusChanged(ref AddNotifyLoginStatusChangedOptions options, object clientData, OnLoginStatusChangedCallback notification)
		{
			AddNotifyLoginStatusChangedOptionsInternal optionsInternal = new AddNotifyLoginStatusChangedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationInternal = new OnLoginStatusChangedCallbackInternal(OnLoginStatusChangedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notification, notificationInternal);

			var funcResult = Bindings.EOS_Auth_AddNotifyLoginStatusChanged(InnerHandle, ref optionsInternal, clientDataAddress, notificationInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Fetch an ID token for an Epic Account ID.
		/// 
		/// ID tokens are used to securely verify user identities with online services.
		/// The most common use case is using an ID token to authenticate the local user by their selected account ID,
		/// which is the account ID that should be used to access any game-scoped data for the current application.
		/// 
		/// An ID token for the selected account ID of a locally authenticated user will always be readily available.
		/// To retrieve it for the selected account ID, you can use <see cref="CopyIdToken" /> directly after a successful user login.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the account ID for which to copy an ID token.</param>
		/// <param name="outIdToken">An ID token for the given user, if it exists and is valid; use <see cref="Release" /> when finished.</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserIdToken
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the Id token is not found or expired.
		/// </returns>
		public Result CopyIdToken(ref CopyIdTokenOptions options, out IdToken? outIdToken)
		{
			CopyIdTokenOptionsInternal optionsInternal = new CopyIdTokenOptionsInternal();
			optionsInternal.Set(ref options);

			var outIdTokenAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Auth_CopyIdToken(InnerHandle, ref optionsInternal, ref outIdTokenAddress);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<IdTokenInternal, IdToken>(outIdTokenAddress, out outIdToken);
			if (outIdToken != null)
			{
				Bindings.EOS_Auth_IdToken_Release(outIdTokenAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Fetch a user auth token for an Epic Account ID.
		/// 
		/// A user authentication token allows any code with possession (backend/client) to perform certain actions on behalf of the user.
		/// Because of this, for the purposes of user identity verification, the <see cref="CopyIdToken" /> API should be used instead.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the api version of CopyUserAuthToken to use</param>
		/// <param name="localUserId">The Epic Account ID of the user being queried</param>
		/// <param name="outUserAuthToken">The auth token for the given user, if it exists and is valid; use <see cref="Release" /> when finished</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserAuthToken
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the auth token is not found or expired.
		/// </returns>
		public Result CopyUserAuthToken(ref CopyUserAuthTokenOptions options, EpicAccountId localUserId, out Token? outUserAuthToken)
		{
			CopyUserAuthTokenOptionsInternal optionsInternal = new CopyUserAuthTokenOptionsInternal();
			optionsInternal.Set(ref options);

			var localUserIdInnerHandle = System.IntPtr.Zero;
			Helper.Set(localUserId, ref localUserIdInnerHandle);

			var outUserAuthTokenAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Auth_CopyUserAuthToken(InnerHandle, ref optionsInternal, localUserIdInnerHandle, ref outUserAuthTokenAddress);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<TokenInternal, Token>(outUserAuthTokenAddress, out outUserAuthToken);
			if (outUserAuthToken != null)
			{
				Bindings.EOS_Auth_Token_Release(outUserAuthTokenAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Deletes a previously received and locally stored persistent auth access token for the currently logged in user of the local device.
		/// 
		/// On Desktop and Mobile platforms, the access token is deleted from the keychain of the local user and a backend request is made to revoke the token on the authentication server.
		/// On Console platforms, even though the caller is responsible for storing and deleting the access token on the local device,
		/// this function should still be called with the access token before its deletion to make the best effort in attempting to also revoke it on the authentication server.
		/// If the function would fail on Console, the caller should still proceed as normal to delete the access token locally as intended.
		/// </summary>
		/// <param name="options">structure containing operation input parameters</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the deletion operation completes, either successfully or in error</param>
		public void DeletePersistentAuth(ref DeletePersistentAuthOptions options, object clientData, OnDeletePersistentAuthCallback completionDelegate)
		{
			DeletePersistentAuthOptionsInternal optionsInternal = new DeletePersistentAuthOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnDeletePersistentAuthCallbackInternal(OnDeletePersistentAuthCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Auth_DeletePersistentAuth(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Fetch an Epic Account ID that is logged in.
		/// </summary>
		/// <param name="index">An index into the list of logged in accounts. If the index is out of bounds, the returned Epic Account ID will be invalid.</param>
		/// <returns>
		/// The Epic Account ID associated with the index passed
		/// </returns>
		public EpicAccountId GetLoggedInAccountByIndex(int index)
		{
			var funcResult = Bindings.EOS_Auth_GetLoggedInAccountByIndex(InnerHandle, index);

			EpicAccountId funcResultReturn;
			Helper.Get(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch the number of accounts that are logged in.
		/// </summary>
		/// <returns>
		/// the number of accounts logged in.
		/// </returns>
		public int GetLoggedInAccountsCount()
		{
			var funcResult = Bindings.EOS_Auth_GetLoggedInAccountsCount(InnerHandle);

			return funcResult;
		}

		/// <summary>
		/// Fetches the login status for an Epic Account ID.
		/// </summary>
		/// <param name="localUserId">The Epic Account ID of the user being queried</param>
		/// <returns>
		/// The enum value of a user's login status
		/// </returns>
		public LoginStatus GetLoginStatus(EpicAccountId localUserId)
		{
			var localUserIdInnerHandle = System.IntPtr.Zero;
			Helper.Set(localUserId, ref localUserIdInnerHandle);

			var funcResult = Bindings.EOS_Auth_GetLoginStatus(InnerHandle, localUserIdInnerHandle);

			return funcResult;
		}

		/// <summary>
		/// Fetch one of the merged account IDs for a given logged in account.
		/// </summary>
		/// <param name="localUserId">The account ID of a currently logged in account.</param>
		/// <param name="index">An index into the list of merged accounts. If the index is out of bounds, the returned Epic Account ID will be invalid.</param>
		/// <returns>
		/// The Epic Account ID associated with the index passed.
		/// </returns>
		public EpicAccountId GetMergedAccountByIndex(EpicAccountId localUserId, uint index)
		{
			var localUserIdInnerHandle = System.IntPtr.Zero;
			Helper.Set(localUserId, ref localUserIdInnerHandle);

			var funcResult = Bindings.EOS_Auth_GetMergedAccountByIndex(InnerHandle, localUserIdInnerHandle, index);

			EpicAccountId funcResultReturn;
			Helper.Get(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch the number of merged accounts for a given logged in account.
		/// </summary>
		/// <param name="localUserId">The account ID of a currently logged in account.</param>
		/// <returns>
		/// the number of merged accounts for the logged in account.
		/// </returns>
		public uint GetMergedAccountsCount(EpicAccountId localUserId)
		{
			var localUserIdInnerHandle = System.IntPtr.Zero;
			Helper.Set(localUserId, ref localUserIdInnerHandle);

			var funcResult = Bindings.EOS_Auth_GetMergedAccountsCount(InnerHandle, localUserIdInnerHandle);

			return funcResult;
		}

		/// <summary>
		/// Fetch the selected account ID to the current application for a local authenticated user.
		/// </summary>
		/// <param name="localUserId">The account ID of a currently logged in account.</param>
		/// <param name="outSelectedAccountId">The selected account ID corresponding to the given account ID.</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the user is logged in and the information is available.
		/// <see cref="Result.InvalidParameters" /> if the output parameter is <see langword="null" />.
		/// <see cref="Result.InvalidUser" /> if the input account ID is not locally known.
		/// <see cref="Result.InvalidAuth" /> if the input account ID is not locally logged in.
		/// <see cref="Result.NotFound" /> otherwise.
		/// </returns>
		public Result GetSelectedAccountId(EpicAccountId localUserId, out EpicAccountId outSelectedAccountId)
		{
			var localUserIdInnerHandle = System.IntPtr.Zero;
			Helper.Set(localUserId, ref localUserIdInnerHandle);

			var outSelectedAccountIdAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Auth_GetSelectedAccountId(InnerHandle, localUserIdInnerHandle, ref outSelectedAccountIdAddress);

			Helper.Get(outSelectedAccountIdAddress, out outSelectedAccountId);

			return funcResult;
		}

		/// <summary>
		/// Link external account by continuing previous login attempt with a continuance token.
		/// 
		/// The user will be presented with Epic Accounts onboarding flow managed by the SDK.
		/// 
		/// On success, the user will be logged in at the completion of this action.
		/// This will commit this external account to the Epic Account and cannot be undone in the SDK.
		/// </summary>
		/// <param name="options">structure containing the account credentials to use during the link account operation</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the link account operation completes, either successfully or in error</param>
		public void LinkAccount(ref LinkAccountOptions options, object clientData, OnLinkAccountCallback completionDelegate)
		{
			LinkAccountOptionsInternal optionsInternal = new LinkAccountOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnLinkAccountCallbackInternal(OnLinkAccountCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Auth_LinkAccount(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Login/Authenticate with user credentials.
		/// </summary>
		/// <param name="options">structure containing the account credentials to use during the login operation</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the login operation completes, either successfully or in error</param>
		public void Login(ref LoginOptions options, object clientData, OnLoginCallback completionDelegate)
		{
			LoginOptionsInternal optionsInternal = new LoginOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnLoginCallbackInternal(OnLoginCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Auth_Login(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Signs the player out of the online service.
		/// </summary>
		/// <param name="options">structure containing information about which account to log out.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the logout operation completes, either successfully or in error</param>
		public void Logout(ref LogoutOptions options, object clientData, OnLogoutCallback completionDelegate)
		{
			LogoutOptionsInternal optionsInternal = new LogoutOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnLogoutCallbackInternal(OnLogoutCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Auth_Logout(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Query the backend for an ID token that describes one of the merged account IDs of a local authenticated user.
		/// 
		/// The ID token can be used to impersonate a merged account ID when communicating with online services.
		/// 
		/// An ID token for the selected account ID of a locally authenticated user will always be readily available and does not need to be queried explicitly.
		/// </summary>
		/// <param name="options">Structure containing the merged account ID for which to query an ID token.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="completionDelegate">A callback that is fired when the operation completes, either successfully or in error.</param>
		public void QueryIdToken(ref QueryIdTokenOptions options, object clientData, OnQueryIdTokenCallback completionDelegate)
		{
			QueryIdTokenOptionsInternal optionsInternal = new QueryIdTokenOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnQueryIdTokenCallbackInternal(OnQueryIdTokenCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Auth_QueryIdToken(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Unregister from receiving login status updates.
		/// </summary>
		/// <param name="inId">handle representing the registered callback</param>
		public void RemoveNotifyLoginStatusChanged(ulong inId)
		{
			Bindings.EOS_Auth_RemoveNotifyLoginStatusChanged(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Verify a given ID token for authenticity and validity.
		/// </summary>
		/// <param name="options">Structure containing information about the ID token to verify.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the operation completes, either successfully or in error.</param>
		public void VerifyIdToken(ref VerifyIdTokenOptions options, object clientData, OnVerifyIdTokenCallback completionDelegate)
		{
			VerifyIdTokenOptionsInternal optionsInternal = new VerifyIdTokenOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnVerifyIdTokenCallbackInternal(OnVerifyIdTokenCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Auth_VerifyIdToken(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Contact the backend service to verify validity of an existing user auth token.
		/// This function is intended for server-side use only.
		/// <seealso cref="CopyUserAuthToken" />
		/// </summary>
		/// <param name="options">structure containing information about the auth token being verified</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the logout operation completes, either successfully or in error</param>
		public void VerifyUserAuth(ref VerifyUserAuthOptions options, object clientData, OnVerifyUserAuthCallback completionDelegate)
		{
			VerifyUserAuthOptionsInternal optionsInternal = new VerifyUserAuthOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnVerifyUserAuthCallbackInternal(OnVerifyUserAuthCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Auth_VerifyUserAuth(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		[MonoPInvokeCallback(typeof(OnDeletePersistentAuthCallbackInternal))]
		internal static void OnDeletePersistentAuthCallbackInternalImplementation(ref DeletePersistentAuthCallbackInfoInternal data)
		{
			OnDeletePersistentAuthCallback callback;
			DeletePersistentAuthCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLinkAccountCallbackInternal))]
		internal static void OnLinkAccountCallbackInternalImplementation(ref LinkAccountCallbackInfoInternal data)
		{
			OnLinkAccountCallback callback;
			LinkAccountCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLoginCallbackInternal))]
		internal static void OnLoginCallbackInternalImplementation(ref LoginCallbackInfoInternal data)
		{
			OnLoginCallback callback;
			LoginCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLoginStatusChangedCallbackInternal))]
		internal static void OnLoginStatusChangedCallbackInternalImplementation(ref LoginStatusChangedCallbackInfoInternal data)
		{
			OnLoginStatusChangedCallback callback;
			LoginStatusChangedCallbackInfo callbackInfo;
			if (Helper.TryGetCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLogoutCallbackInternal))]
		internal static void OnLogoutCallbackInternalImplementation(ref LogoutCallbackInfoInternal data)
		{
			OnLogoutCallback callback;
			LogoutCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnQueryIdTokenCallbackInternal))]
		internal static void OnQueryIdTokenCallbackInternalImplementation(ref QueryIdTokenCallbackInfoInternal data)
		{
			OnQueryIdTokenCallback callback;
			QueryIdTokenCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnVerifyIdTokenCallbackInternal))]
		internal static void OnVerifyIdTokenCallbackInternalImplementation(ref VerifyIdTokenCallbackInfoInternal data)
		{
			OnVerifyIdTokenCallback callback;
			VerifyIdTokenCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnVerifyUserAuthCallbackInternal))]
		internal static void OnVerifyUserAuthCallbackInternalImplementation(ref VerifyUserAuthCallbackInfoInternal data)
		{
			OnVerifyUserAuthCallback callback;
			VerifyUserAuthCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}
	}
}