// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.RTCAdmin
{
	public sealed partial class RTCAdminInterface : Handle
	{
		public RTCAdminInterface()
		{
		}

		public RTCAdminInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="CopyUserTokenByIndexOptions" /> struct.
		/// </summary>
		public const int CopyusertokenbyindexApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="CopyUserTokenByUserIdOptions" /> struct.
		/// </summary>
		public const int CopyusertokenbyuseridApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="Kick" /> API
		/// </summary>
		public const int KickApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="QueryJoinRoomToken" /> API
		/// </summary>
		public const int QueryjoinroomtokenApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="SetParticipantHardMuteOptions" /> struct.
		/// </summary>
		public const int SetparticipanthardmuteApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UserToken" /> struct.
		/// </summary>
		public const int UsertokenApiLatest = 1;

		/// <summary>
		/// Fetches a user token when called inside of the OnQueryJoinRoomTokenComplete callback.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the index being accessed</param>
		/// <param name="outUserToken">
		/// The user token for the given index, if it exists and is valid. Use <see cref="Release" /> when finished
		/// @note The order of the tokens doesn't necessarily match the order of the <see cref="ProductUserId" /> array specified in the <see cref="QueryJoinRoomTokenOptions" /> when
		/// initiating the query.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserToken
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the user token is not found
		/// </returns>
		public Result CopyUserTokenByIndex(CopyUserTokenByIndexOptions options, out UserToken outUserToken)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyUserTokenByIndexOptionsInternal, CopyUserTokenByIndexOptions>(ref optionsAddress, options);

			var outUserTokenAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_RTCAdmin_CopyUserTokenByIndex(InnerHandle, optionsAddress, ref outUserTokenAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			if (Helper.TryMarshalGet<UserTokenInternal, UserToken>(outUserTokenAddress, out outUserToken))
			{
				Bindings.EOS_RTCAdmin_UserToken_Release(outUserTokenAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Fetches a user token for a given user ID when called inside of the OnQueryJoinRoomTokenComplete callback.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the user ID being accessed</param>
		/// <param name="outUserToken">The user token for the given user ID, if it exists and is valid. Use <see cref="Release" /> when finished</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserToken
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the user token is not found
		/// </returns>
		public Result CopyUserTokenByUserId(CopyUserTokenByUserIdOptions options, out UserToken outUserToken)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyUserTokenByUserIdOptionsInternal, CopyUserTokenByUserIdOptions>(ref optionsAddress, options);

			var outUserTokenAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_RTCAdmin_CopyUserTokenByUserId(InnerHandle, optionsAddress, ref outUserTokenAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			if (Helper.TryMarshalGet<UserTokenInternal, UserToken>(outUserTokenAddress, out outUserToken))
			{
				Bindings.EOS_RTCAdmin_UserToken_Release(outUserTokenAddress);
			}

			return funcResult;
		}

		/// <summary>
		/// Starts an asynchronous task that removes a participant from a room and revokes their token.
		/// </summary>
		/// <param name="options">structure containing the room and user to revoke the token from.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		public void Kick(KickOptions options, object clientData, OnKickCompleteCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<KickOptionsInternal, KickOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnKickCompleteCallbackInternal(OnKickCompleteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_RTCAdmin_Kick(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Query for a list of user tokens for joining a room.
		/// 
		/// Each query generates a query id ( see <see cref="QueryJoinRoomTokenCompleteCallbackInfo" /> ) which should be used
		/// to retrieve the tokens from inside the callback.
		/// </summary>
		/// <param name="options">Structure containing information about the application whose user tokens we're retrieving.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">This function is called when the query join room token operation completes.</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public void QueryJoinRoomToken(QueryJoinRoomTokenOptions options, object clientData, OnQueryJoinRoomTokenCompleteCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<QueryJoinRoomTokenOptionsInternal, QueryJoinRoomTokenOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnQueryJoinRoomTokenCompleteCallbackInternal(OnQueryJoinRoomTokenCompleteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_RTCAdmin_QueryJoinRoomToken(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Starts an asynchronous task remotely mutes/unmutes a room participant.
		/// 
		/// This remotely mutes the specified participant, so no audio is sent from that participant to any other participant in the room.
		/// </summary>
		/// <param name="options">structure containing the room and user to mute.</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the async operation completes, either successfully or in error</param>
		public void SetParticipantHardMute(SetParticipantHardMuteOptions options, object clientData, OnSetParticipantHardMuteCompleteCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<SetParticipantHardMuteOptionsInternal, SetParticipantHardMuteOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnSetParticipantHardMuteCompleteCallbackInternal(OnSetParticipantHardMuteCompleteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_RTCAdmin_SetParticipantHardMute(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		[MonoPInvokeCallback(typeof(OnKickCompleteCallbackInternal))]
		internal static void OnKickCompleteCallbackInternalImplementation(System.IntPtr data)
		{
			OnKickCompleteCallback callback;
			KickCompleteCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnKickCompleteCallback, KickCompleteCallbackInfoInternal, KickCompleteCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnQueryJoinRoomTokenCompleteCallbackInternal))]
		internal static void OnQueryJoinRoomTokenCompleteCallbackInternalImplementation(System.IntPtr data)
		{
			OnQueryJoinRoomTokenCompleteCallback callback;
			QueryJoinRoomTokenCompleteCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnQueryJoinRoomTokenCompleteCallback, QueryJoinRoomTokenCompleteCallbackInfoInternal, QueryJoinRoomTokenCompleteCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnSetParticipantHardMuteCompleteCallbackInternal))]
		internal static void OnSetParticipantHardMuteCompleteCallbackInternalImplementation(System.IntPtr data)
		{
			OnSetParticipantHardMuteCompleteCallback callback;
			SetParticipantHardMuteCompleteCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnSetParticipantHardMuteCompleteCallback, SetParticipantHardMuteCompleteCallbackInfoInternal, SetParticipantHardMuteCompleteCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}
	}
}