// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.AntiCheatServer
{
	public sealed partial class AntiCheatServerInterface : Handle
	{
		public AntiCheatServerInterface()
		{
		}

		public AntiCheatServerInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		public const int AddnotifyclientactionrequiredApiLatest = 1;

		public const int AddnotifyclientauthstatuschangedApiLatest = 1;

		public const int AddnotifymessagetoclientApiLatest = 1;

		public const int BeginsessionApiLatest = 3;

		public const int BeginsessionMaxRegistertimeout = 120;

		/// <summary>
		/// Limits on RegisterTimeoutSeconds parameter
		/// </summary>
		public const int BeginsessionMinRegistertimeout = 10;

		public const int EndsessionApiLatest = 1;

		public const int GetprotectmessageoutputlengthApiLatest = 1;

		public const int ProtectmessageApiLatest = 1;

		public const int ReceivemessagefromclientApiLatest = 1;

		public const int RegisterclientApiLatest = 1;

		public const int SetclientnetworkstateApiLatest = 1;

		public const int UnprotectmessageApiLatest = 1;

		public const int UnregisterclientApiLatest = 1;

		/// <summary>
		/// Add a callback issued when an action must be applied to a connected client. The bound function
		/// will only be called between a successful call to <see cref="BeginSession" /> and the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data</param>
		/// <param name="clientData">This value is returned to the caller when NotificationFn is invoked</param>
		/// <param name="notificationFn">The callback to be fired</param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.InvalidNotificationid" /> otherwise
		/// </returns>
		public ulong AddNotifyClientActionRequired(AddNotifyClientActionRequiredOptions options, object clientData, OnClientActionRequiredCallback notificationFn)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyClientActionRequiredOptionsInternal, AddNotifyClientActionRequiredOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnClientActionRequiredCallbackInternal(OnClientActionRequiredCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_AntiCheatServer_AddNotifyClientActionRequired(InnerHandle, optionsAddress, clientDataAddress, notificationFnInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Add an optional callback issued when a connected client's authentication status changes. The bound function
		/// will only be called between a successful call to <see cref="BeginSession" /> and the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data</param>
		/// <param name="clientData">This value is returned to the caller when NotificationFn is invoked</param>
		/// <param name="notificationFn">The callback to be fired</param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.InvalidNotificationid" /> otherwise
		/// </returns>
		public ulong AddNotifyClientAuthStatusChanged(AddNotifyClientAuthStatusChangedOptions options, object clientData, OnClientAuthStatusChangedCallback notificationFn)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyClientAuthStatusChangedOptionsInternal, AddNotifyClientAuthStatusChangedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnClientAuthStatusChangedCallbackInternal(OnClientAuthStatusChangedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_AntiCheatServer_AddNotifyClientAuthStatusChanged(InnerHandle, optionsAddress, clientDataAddress, notificationFnInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Add a callback issued when a new message must be dispatched to a connected client. The bound function
		/// will only be called between a successful call to <see cref="BeginSession" /> and the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data</param>
		/// <param name="clientData">This value is returned to the caller when NotificationFn is invoked</param>
		/// <param name="notificationFn">The callback to be fired</param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.InvalidNotificationid" /> otherwise
		/// </returns>
		public ulong AddNotifyMessageToClient(AddNotifyMessageToClientOptions options, object clientData, OnMessageToClientCallback notificationFn)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyMessageToClientOptionsInternal, AddNotifyMessageToClientOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnMessageToClientCallbackInternal(OnMessageToClientCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_AntiCheatServer_AddNotifyMessageToClient(InnerHandle, optionsAddress, clientDataAddress, notificationFnInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Begin the gameplay session. Event callbacks must be configured with <see cref="AddNotifyMessageToClient" />
		/// and <see cref="AddNotifyClientActionRequired" /> before calling this function.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the initialization succeeded
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result BeginSession(BeginSessionOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<BeginSessionOptionsInternal, BeginSessionOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_BeginSession(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// End the gameplay session. Should be called when the server is shutting down or entering an idle state.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the initialization succeeded
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result EndSession(EndSessionOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<EndSessionOptionsInternal, EndSessionOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_EndSession(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional NetProtect feature for game message encryption.
		/// Calculates the required decrypted buffer size for a given input data length.
		/// This will not change for a given SDK version, and allows one time allocation of reusable buffers.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <param name="outBufferLengthBytes">The length in bytes that is required to call ProtectMessage on the given input size.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the output length was calculated successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result GetProtectMessageOutputLength(GetProtectMessageOutputLengthOptions options, out uint outBufferLengthBytes)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetProtectMessageOutputLengthOptionsInternal, GetProtectMessageOutputLengthOptions>(ref optionsAddress, options);

			outBufferLengthBytes = Helper.GetDefault<uint>();

			var funcResult = Bindings.EOS_AntiCheatServer_GetProtectMessageOutputLength(InnerHandle, optionsAddress, ref outBufferLengthBytes);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a custom gameplay event.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogEvent(AntiCheatCommon.LogEventOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.LogEventOptionsInternal, AntiCheatCommon.LogEventOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogEvent(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a game round's end and outcome.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogGameRoundEnd(AntiCheatCommon.LogGameRoundEndOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.LogGameRoundEndOptionsInternal, AntiCheatCommon.LogGameRoundEndOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogGameRoundEnd(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a new game round start.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogGameRoundStart(AntiCheatCommon.LogGameRoundStartOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.LogGameRoundStartOptionsInternal, AntiCheatCommon.LogGameRoundStartOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogGameRoundStart(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player despawning in the game, for example as a result of the character's death,
		/// switching to spectator mode, etc.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerDespawn(AntiCheatCommon.LogPlayerDespawnOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.LogPlayerDespawnOptionsInternal, AntiCheatCommon.LogPlayerDespawnOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerDespawn(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player being revived after being downed (see <see cref="LogPlayerTakeDamage" /> options).
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerRevive(AntiCheatCommon.LogPlayerReviveOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.LogPlayerReviveOptionsInternal, AntiCheatCommon.LogPlayerReviveOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerRevive(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player spawning into the game.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerSpawn(AntiCheatCommon.LogPlayerSpawnOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.LogPlayerSpawnOptionsInternal, AntiCheatCommon.LogPlayerSpawnOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerSpawn(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs that a player has taken damage.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerTakeDamage(AntiCheatCommon.LogPlayerTakeDamageOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.LogPlayerTakeDamageOptionsInternal, AntiCheatCommon.LogPlayerTakeDamageOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerTakeDamage(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player's general state including position and view direction.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerTick(AntiCheatCommon.LogPlayerTickOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.LogPlayerTickOptionsInternal, AntiCheatCommon.LogPlayerTickOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerTick(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs that a player has used a special ability or item which affects their character's capabilities,
		/// for example temporarily increasing their speed or allowing them to see nearby players behind walls.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerUseAbility(AntiCheatCommon.LogPlayerUseAbilityOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.LogPlayerUseAbilityOptionsInternal, AntiCheatCommon.LogPlayerUseAbilityOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerUseAbility(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs that a player has used a weapon, for example firing one bullet or making one melee attack.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerUseWeapon(AntiCheatCommon.LogPlayerUseWeaponOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.LogPlayerUseWeaponOptionsInternal, AntiCheatCommon.LogPlayerUseWeaponOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerUseWeapon(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional NetProtect feature for game message encryption.
		/// Encrypts an arbitrary message that will be sent to a game client and decrypted on the other side.
		/// 
		/// Options.Data and OutBuffer may refer to the same buffer to encrypt in place.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <param name="outBuffer">On success, buffer where encrypted message data will be written.</param>
		/// <param name="outBufferLengthBytes">Number of bytes that were written to OutBuffer.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the message was protected successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.InvalidUser" /> - If the specified ClientHandle was invalid or not currently registered. See RegisterClient.
		/// </returns>
		public Result ProtectMessage(ProtectMessageOptions options, out byte[] outBuffer)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<ProtectMessageOptionsInternal, ProtectMessageOptions>(ref optionsAddress, options);

			System.IntPtr outBufferAddress = System.IntPtr.Zero;
			uint outBufferLengthBytes = options.OutBufferSizeBytes;
			Helper.TryMarshalAllocate(ref outBufferAddress, outBufferLengthBytes, out _);

			var funcResult = Bindings.EOS_AntiCheatServer_ProtectMessage(InnerHandle, optionsAddress, outBufferAddress, ref outBufferLengthBytes);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outBufferAddress, out outBuffer, outBufferLengthBytes);
			Helper.TryMarshalDispose(ref outBufferAddress);

			return funcResult;
		}

		/// <summary>
		/// Call when an anti-cheat message is received from a client.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the message was processed successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result ReceiveMessageFromClient(ReceiveMessageFromClientOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<ReceiveMessageFromClientOptionsInternal, ReceiveMessageFromClientOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_ReceiveMessageFromClient(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Register a connected client. Must be paired with a call to UnregisterClient.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the player was registered successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result RegisterClient(RegisterClientOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<RegisterClientOptionsInternal, RegisterClientOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_RegisterClient(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Registers a custom gameplay event.
		/// 
		/// All custom game events must be registered before <see cref="BeginSession" /> is called for the first time.
		/// After the first call to <see cref="BeginSession" />, this function cannot be called any longer.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was registered successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result RegisterEvent(AntiCheatCommon.RegisterEventOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.RegisterEventOptionsInternal, AntiCheatCommon.RegisterEventOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_RegisterEvent(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Remove a previously bound <see cref="AddNotifyClientActionRequired" /> handler.
		/// </summary>
		/// <param name="notificationId">The previously bound notification ID</param>
		public void RemoveNotifyClientActionRequired(ulong notificationId)
		{
			Helper.TryRemoveCallbackByNotificationId(notificationId);

			Bindings.EOS_AntiCheatServer_RemoveNotifyClientActionRequired(InnerHandle, notificationId);
		}

		/// <summary>
		/// Remove a previously bound <see cref="AddNotifyClientAuthStatusChanged" /> handler.
		/// </summary>
		/// <param name="notificationId">The previously bound notification ID</param>
		public void RemoveNotifyClientAuthStatusChanged(ulong notificationId)
		{
			Helper.TryRemoveCallbackByNotificationId(notificationId);

			Bindings.EOS_AntiCheatServer_RemoveNotifyClientAuthStatusChanged(InnerHandle, notificationId);
		}

		/// <summary>
		/// Remove a previously bound <see cref="AddNotifyMessageToClient" /> handler.
		/// </summary>
		/// <param name="notificationId">The previously bound notification ID</param>
		public void RemoveNotifyMessageToClient(ulong notificationId)
		{
			Helper.TryRemoveCallbackByNotificationId(notificationId);

			Bindings.EOS_AntiCheatServer_RemoveNotifyMessageToClient(InnerHandle, notificationId);
		}

		/// <summary>
		/// Optional. Sets or updates client details including input device and admin status.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the flags were updated successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result SetClientDetails(AntiCheatCommon.SetClientDetailsOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.SetClientDetailsOptionsInternal, AntiCheatCommon.SetClientDetailsOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_SetClientDetails(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional. Can be used to indicate that a client is legitimately known to be
		/// temporarily unable to communicate, for example as a result of loading a new level.
		/// 
		/// The bIsNetworkActive flag must be set back to true when users enter normal
		/// gameplay, otherwise anti-cheat enforcement will not work correctly.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the network state was updated successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result SetClientNetworkState(SetClientNetworkStateOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<SetClientNetworkStateOptionsInternal, SetClientNetworkStateOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_SetClientNetworkState(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional. Sets or updates a game session identifier which can be attached to other data for reference.
		/// The identifier can be updated at any time for currently and subsequently registered clients.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the game session identifier was set successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result SetGameSessionId(AntiCheatCommon.SetGameSessionIdOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AntiCheatCommon.SetGameSessionIdOptionsInternal, AntiCheatCommon.SetGameSessionIdOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_SetGameSessionId(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Optional NetProtect feature for game message encryption.
		/// Decrypts an encrypted message received from a game client.
		/// 
		/// Options.Data and OutBuffer may refer to the same buffer to decrypt in place.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <param name="outBuffer">On success, buffer where encrypted message data will be written.</param>
		/// <param name="outBufferLengthBytes">Number of bytes that were written to OutBuffer.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the message was unprotected successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result UnprotectMessage(UnprotectMessageOptions options, out byte[] outBuffer)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<UnprotectMessageOptionsInternal, UnprotectMessageOptions>(ref optionsAddress, options);

			System.IntPtr outBufferAddress = System.IntPtr.Zero;
			uint outBufferLengthBytes = options.OutBufferSizeBytes;
			Helper.TryMarshalAllocate(ref outBufferAddress, outBufferLengthBytes, out _);

			var funcResult = Bindings.EOS_AntiCheatServer_UnprotectMessage(InnerHandle, optionsAddress, outBufferAddress, ref outBufferLengthBytes);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outBufferAddress, out outBuffer, outBufferLengthBytes);
			Helper.TryMarshalDispose(ref outBufferAddress);

			return funcResult;
		}

		/// <summary>
		/// Unregister a disconnected client.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the player was unregistered successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result UnregisterClient(UnregisterClientOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<UnregisterClientOptionsInternal, UnregisterClientOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_AntiCheatServer_UnregisterClient(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		[MonoPInvokeCallback(typeof(OnClientActionRequiredCallbackInternal))]
		internal static void OnClientActionRequiredCallbackInternalImplementation(System.IntPtr data)
		{
			OnClientActionRequiredCallback callback;
			AntiCheatCommon.OnClientActionRequiredCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnClientActionRequiredCallback, AntiCheatCommon.OnClientActionRequiredCallbackInfoInternal, AntiCheatCommon.OnClientActionRequiredCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnClientAuthStatusChangedCallbackInternal))]
		internal static void OnClientAuthStatusChangedCallbackInternalImplementation(System.IntPtr data)
		{
			OnClientAuthStatusChangedCallback callback;
			AntiCheatCommon.OnClientAuthStatusChangedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnClientAuthStatusChangedCallback, AntiCheatCommon.OnClientAuthStatusChangedCallbackInfoInternal, AntiCheatCommon.OnClientAuthStatusChangedCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnMessageToClientCallbackInternal))]
		internal static void OnMessageToClientCallbackInternalImplementation(System.IntPtr data)
		{
			OnMessageToClientCallback callback;
			AntiCheatCommon.OnMessageToClientCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnMessageToClientCallback, AntiCheatCommon.OnMessageToClientCallbackInfoInternal, AntiCheatCommon.OnMessageToClientCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}
	}
}