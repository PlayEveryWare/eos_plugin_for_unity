// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.AntiCheatServer
{
	public sealed partial class AntiCheatServerInterface : Handle
	{
		public AntiCheatServerInterface()
		{
		}

		public AntiCheatServerInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		public const int AddnotifyclientactionrequiredApiLatest = 1;

		public const int AddnotifyclientauthstatuschangedApiLatest = 1;

		public const int AddnotifymessagetoclientApiLatest = 1;

		public const int BeginsessionApiLatest = 3;

		public const int BeginsessionMaxRegistertimeout = 120;

		/// <summary>
		/// Limits on RegisterTimeoutSeconds parameter
		/// </summary>
		public const int BeginsessionMinRegistertimeout = 10;

		public const int EndsessionApiLatest = 1;

		public const int GetprotectmessageoutputlengthApiLatest = 1;

		public const int ProtectmessageApiLatest = 1;

		public const int ReceivemessagefromclientApiLatest = 1;

		public const int RegisterclientApiLatest = 2;

		public const int SetclientnetworkstateApiLatest = 1;

		public const int UnprotectmessageApiLatest = 1;

		public const int UnregisterclientApiLatest = 1;

		/// <summary>
		/// Add a callback issued when an action must be applied to a connected client. The bound function
		/// will only be called between a successful call to <see cref="BeginSession" /> and the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data</param>
		/// <param name="clientData">This value is returned to the caller when NotificationFn is invoked</param>
		/// <param name="notificationFn">The callback to be fired</param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.InvalidNotificationid" /> otherwise
		/// </returns>
		public ulong AddNotifyClientActionRequired(ref AddNotifyClientActionRequiredOptions options, object clientData, OnClientActionRequiredCallback notificationFn)
		{
			AddNotifyClientActionRequiredOptionsInternal optionsInternal = new AddNotifyClientActionRequiredOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnClientActionRequiredCallbackInternal(OnClientActionRequiredCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_AntiCheatServer_AddNotifyClientActionRequired(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Add an optional callback issued when a connected client's authentication status changes. The bound function
		/// will only be called between a successful call to <see cref="BeginSession" /> and the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data</param>
		/// <param name="clientData">This value is returned to the caller when NotificationFn is invoked</param>
		/// <param name="notificationFn">The callback to be fired</param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.InvalidNotificationid" /> otherwise
		/// </returns>
		public ulong AddNotifyClientAuthStatusChanged(ref AddNotifyClientAuthStatusChangedOptions options, object clientData, OnClientAuthStatusChangedCallback notificationFn)
		{
			AddNotifyClientAuthStatusChangedOptionsInternal optionsInternal = new AddNotifyClientAuthStatusChangedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnClientAuthStatusChangedCallbackInternal(OnClientAuthStatusChangedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_AntiCheatServer_AddNotifyClientAuthStatusChanged(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Add a callback issued when a new message must be dispatched to a connected client. The bound function
		/// will only be called between a successful call to <see cref="BeginSession" /> and the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data</param>
		/// <param name="clientData">This value is returned to the caller when NotificationFn is invoked</param>
		/// <param name="notificationFn">The callback to be fired</param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.InvalidNotificationid" /> otherwise
		/// </returns>
		public ulong AddNotifyMessageToClient(ref AddNotifyMessageToClientOptions options, object clientData, OnMessageToClientCallback notificationFn)
		{
			AddNotifyMessageToClientOptionsInternal optionsInternal = new AddNotifyMessageToClientOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnMessageToClientCallbackInternal(OnMessageToClientCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_AntiCheatServer_AddNotifyMessageToClient(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Begin the gameplay session. Event callbacks must be configured with <see cref="AddNotifyMessageToClient" />
		/// and <see cref="AddNotifyClientActionRequired" /> before calling this function.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the initialization succeeded
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result BeginSession(ref BeginSessionOptions options)
		{
			BeginSessionOptionsInternal optionsInternal = new BeginSessionOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_BeginSession(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// End the gameplay session. Should be called when the server is shutting down or entering an idle state.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the initialization succeeded
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result EndSession(ref EndSessionOptions options)
		{
			EndSessionOptionsInternal optionsInternal = new EndSessionOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_EndSession(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional NetProtect feature for game message encryption.
		/// Calculates the required decrypted buffer size for a given input data length.
		/// This will not change for a given SDK version, and allows one time allocation of reusable buffers.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <param name="outBufferLengthBytes">On success, the OutBuffer length in bytes that is required to call ProtectMessage on the given input size.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the output length was calculated successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result GetProtectMessageOutputLength(ref GetProtectMessageOutputLengthOptions options, out uint outBufferSizeBytes)
		{
			GetProtectMessageOutputLengthOptionsInternal optionsInternal = new GetProtectMessageOutputLengthOptionsInternal();
			optionsInternal.Set(ref options);

			outBufferSizeBytes = Helper.GetDefault<uint>();

			var funcResult = Bindings.EOS_AntiCheatServer_GetProtectMessageOutputLength(InnerHandle, ref optionsInternal, ref outBufferSizeBytes);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a custom gameplay event.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogEvent(ref AntiCheatCommon.LogEventOptions options)
		{
			AntiCheatCommon.LogEventOptionsInternal optionsInternal = new AntiCheatCommon.LogEventOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogEvent(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a game round's end and outcome.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogGameRoundEnd(ref AntiCheatCommon.LogGameRoundEndOptions options)
		{
			AntiCheatCommon.LogGameRoundEndOptionsInternal optionsInternal = new AntiCheatCommon.LogGameRoundEndOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogGameRoundEnd(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a new game round start.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogGameRoundStart(ref AntiCheatCommon.LogGameRoundStartOptions options)
		{
			AntiCheatCommon.LogGameRoundStartOptionsInternal optionsInternal = new AntiCheatCommon.LogGameRoundStartOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogGameRoundStart(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player despawning in the game, for example as a result of the character's death,
		/// switching to spectator mode, etc.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerDespawn(ref AntiCheatCommon.LogPlayerDespawnOptions options)
		{
			AntiCheatCommon.LogPlayerDespawnOptionsInternal optionsInternal = new AntiCheatCommon.LogPlayerDespawnOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerDespawn(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player being revived after being downed (see <see cref="LogPlayerTakeDamage" /> options).
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerRevive(ref AntiCheatCommon.LogPlayerReviveOptions options)
		{
			AntiCheatCommon.LogPlayerReviveOptionsInternal optionsInternal = new AntiCheatCommon.LogPlayerReviveOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerRevive(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player spawning into the game.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerSpawn(ref AntiCheatCommon.LogPlayerSpawnOptions options)
		{
			AntiCheatCommon.LogPlayerSpawnOptionsInternal optionsInternal = new AntiCheatCommon.LogPlayerSpawnOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerSpawn(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs that a player has taken damage.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerTakeDamage(ref AntiCheatCommon.LogPlayerTakeDamageOptions options)
		{
			AntiCheatCommon.LogPlayerTakeDamageOptionsInternal optionsInternal = new AntiCheatCommon.LogPlayerTakeDamageOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerTakeDamage(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player's general state including position and view direction.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerTick(ref AntiCheatCommon.LogPlayerTickOptions options)
		{
			AntiCheatCommon.LogPlayerTickOptionsInternal optionsInternal = new AntiCheatCommon.LogPlayerTickOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerTick(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs that a player has used a special ability or item which affects their character's capabilities,
		/// for example temporarily increasing their speed or allowing them to see nearby players behind walls.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerUseAbility(ref AntiCheatCommon.LogPlayerUseAbilityOptions options)
		{
			AntiCheatCommon.LogPlayerUseAbilityOptionsInternal optionsInternal = new AntiCheatCommon.LogPlayerUseAbilityOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerUseAbility(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs that a player has used a weapon, for example firing one bullet or making one melee attack.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result LogPlayerUseWeapon(ref AntiCheatCommon.LogPlayerUseWeaponOptions options)
		{
			AntiCheatCommon.LogPlayerUseWeaponOptionsInternal optionsInternal = new AntiCheatCommon.LogPlayerUseWeaponOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_LogPlayerUseWeapon(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional NetProtect feature for game message encryption.
		/// Encrypts an arbitrary message that will be sent to a game client and decrypted on the other side.
		/// 
		/// Options.Data and OutBuffer may refer to the same buffer to encrypt in place.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <param name="outBuffer">On success, buffer where encrypted message data will be written.</param>
		/// <param name="outBytesWritten">On success, the number of bytes that were written to OutBuffer.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the message was protected successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.InvalidUser" /> - If the specified ClientHandle was invalid or not currently registered. See RegisterClient.
		/// </returns>
		public Result ProtectMessage(ref ProtectMessageOptions options, System.ArraySegment<byte> outBuffer, out uint outBytesWritten)
		{
			ProtectMessageOptionsInternal optionsInternal = new ProtectMessageOptionsInternal();
			optionsInternal.Set(ref options);

			outBytesWritten = 0;
			System.IntPtr outBufferAddress = Helper.AddPinnedBuffer(outBuffer);

			var funcResult = Bindings.EOS_AntiCheatServer_ProtectMessage(InnerHandle, ref optionsInternal, outBufferAddress, ref outBytesWritten);

			Helper.Dispose(ref optionsInternal);

			Helper.Dispose(ref outBufferAddress);

			return funcResult;
		}

		/// <summary>
		/// Call when an anti-cheat message is received from a client.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the message was processed successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.InvalidRequest" /> - If message contents were corrupt and could not be processed
		/// </returns>
		public Result ReceiveMessageFromClient(ref ReceiveMessageFromClientOptions options)
		{
			ReceiveMessageFromClientOptionsInternal optionsInternal = new ReceiveMessageFromClientOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_ReceiveMessageFromClient(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Register a connected client. Must be paired with a call to UnregisterClient.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the player was registered successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result RegisterClient(ref RegisterClientOptions options)
		{
			RegisterClientOptionsInternal optionsInternal = new RegisterClientOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_RegisterClient(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Registers a custom gameplay event.
		/// 
		/// All custom game events must be registered before <see cref="BeginSession" /> is called for the first time.
		/// After the first call to <see cref="BeginSession" />, this function cannot be called any longer.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was registered successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result RegisterEvent(ref AntiCheatCommon.RegisterEventOptions options)
		{
			AntiCheatCommon.RegisterEventOptionsInternal optionsInternal = new AntiCheatCommon.RegisterEventOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_RegisterEvent(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Remove a previously bound <see cref="AddNotifyClientActionRequired" /> handler.
		/// </summary>
		/// <param name="notificationId">The previously bound notification ID</param>
		public void RemoveNotifyClientActionRequired(ulong notificationId)
		{
			Bindings.EOS_AntiCheatServer_RemoveNotifyClientActionRequired(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Remove a previously bound <see cref="AddNotifyClientAuthStatusChanged" /> handler.
		/// </summary>
		/// <param name="notificationId">The previously bound notification ID</param>
		public void RemoveNotifyClientAuthStatusChanged(ulong notificationId)
		{
			Bindings.EOS_AntiCheatServer_RemoveNotifyClientAuthStatusChanged(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Remove a previously bound <see cref="AddNotifyMessageToClient" /> handler.
		/// </summary>
		/// <param name="notificationId">The previously bound notification ID</param>
		public void RemoveNotifyMessageToClient(ulong notificationId)
		{
			Bindings.EOS_AntiCheatServer_RemoveNotifyMessageToClient(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Optional. Sets or updates client details including input device and admin status.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the flags were updated successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result SetClientDetails(ref AntiCheatCommon.SetClientDetailsOptions options)
		{
			AntiCheatCommon.SetClientDetailsOptionsInternal optionsInternal = new AntiCheatCommon.SetClientDetailsOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_SetClientDetails(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional. Can be used to indicate that a client is legitimately known to be
		/// temporarily unable to communicate, for example as a result of loading a new level.
		/// 
		/// The bIsNetworkActive flag must be set back to true when users enter normal
		/// gameplay, otherwise anti-cheat enforcement will not work correctly.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the network state was updated successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result SetClientNetworkState(ref SetClientNetworkStateOptions options)
		{
			SetClientNetworkStateOptionsInternal optionsInternal = new SetClientNetworkStateOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_SetClientNetworkState(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional. Sets or updates a game session identifier which can be attached to other data for reference.
		/// The identifier can be updated at any time for currently and subsequently registered clients.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the game session identifier was set successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result SetGameSessionId(ref AntiCheatCommon.SetGameSessionIdOptions options)
		{
			AntiCheatCommon.SetGameSessionIdOptionsInternal optionsInternal = new AntiCheatCommon.SetGameSessionIdOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_SetGameSessionId(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Optional NetProtect feature for game message encryption.
		/// Decrypts an encrypted message received from a game client.
		/// 
		/// Options.Data and OutBuffer may refer to the same buffer to decrypt in place.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <param name="outBuffer">On success, buffer where encrypted message data will be written.</param>
		/// <param name="outBytesWritten">On success, the number of bytes that were written to OutBuffer.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the message was unprotected successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result UnprotectMessage(ref UnprotectMessageOptions options, System.ArraySegment<byte> outBuffer, out uint outBytesWritten)
		{
			UnprotectMessageOptionsInternal optionsInternal = new UnprotectMessageOptionsInternal();
			optionsInternal.Set(ref options);

			outBytesWritten = 0;
			System.IntPtr outBufferAddress = Helper.AddPinnedBuffer(outBuffer);

			var funcResult = Bindings.EOS_AntiCheatServer_UnprotectMessage(InnerHandle, ref optionsInternal, outBufferAddress, ref outBytesWritten);

			Helper.Dispose(ref optionsInternal);

			Helper.Dispose(ref outBufferAddress);

			return funcResult;
		}

		/// <summary>
		/// Unregister a disconnected client.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">Structure containing input data.</param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the player was unregistered successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result UnregisterClient(ref UnregisterClientOptions options)
		{
			UnregisterClientOptionsInternal optionsInternal = new UnregisterClientOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_AntiCheatServer_UnregisterClient(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		[MonoPInvokeCallback(typeof(OnClientActionRequiredCallbackInternal))]
		internal static void OnClientActionRequiredCallbackInternalImplementation(ref AntiCheatCommon.OnClientActionRequiredCallbackInfoInternal data)
		{
			OnClientActionRequiredCallback callback;
			AntiCheatCommon.OnClientActionRequiredCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnClientAuthStatusChangedCallbackInternal))]
		internal static void OnClientAuthStatusChangedCallbackInternalImplementation(ref AntiCheatCommon.OnClientAuthStatusChangedCallbackInfoInternal data)
		{
			OnClientAuthStatusChangedCallback callback;
			AntiCheatCommon.OnClientAuthStatusChangedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnMessageToClientCallbackInternal))]
		internal static void OnMessageToClientCallbackInternalImplementation(ref AntiCheatCommon.OnMessageToClientCallbackInfoInternal data)
		{
			OnMessageToClientCallback callback;
			AntiCheatCommon.OnMessageToClientCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}
	}
}