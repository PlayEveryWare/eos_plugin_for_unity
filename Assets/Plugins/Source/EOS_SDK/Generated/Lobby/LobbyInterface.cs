// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.Lobby
{
	public sealed partial class LobbyInterface : Handle
	{
		public LobbyInterface()
		{
		}

		public LobbyInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyJoinLobbyAccepted" /> API.
		/// </summary>
		public const int AddnotifyjoinlobbyacceptedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLeaveLobbyRequested" /> API.
		/// </summary>
		public const int AddnotifyleavelobbyrequestedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLobbyInviteAccepted" /> API.
		/// </summary>
		public const int AddnotifylobbyinviteacceptedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLobbyInviteReceived" /> API.
		/// </summary>
		public const int AddnotifylobbyinvitereceivedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLobbyInviteRejected" /> API.
		/// </summary>
		public const int AddnotifylobbyinviterejectedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLobbyMemberStatusReceived" /> API.
		/// </summary>
		public const int AddnotifylobbymemberstatusreceivedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLobbyMemberUpdateReceived" /> API.
		/// </summary>
		public const int AddnotifylobbymemberupdatereceivedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLobbyUpdateReceived" /> API.
		/// </summary>
		public const int AddnotifylobbyupdatereceivedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyRTCRoomConnectionChanged" /> API.
		/// </summary>
		public const int AddnotifyrtcroomconnectionchangedApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifySendLobbyNativeInviteRequested" /> API.
		/// </summary>
		public const int AddnotifysendlobbynativeinviterequestedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="Attribute" /> struct.
		/// </summary>
		public const int AttributeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AttributeData" /> struct.
		/// </summary>
		public const int AttributedataApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyLobbyDetailsHandle" /> API.
		/// </summary>
		public const int CopylobbydetailshandleApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyLobbyDetailsHandleByInviteId" /> API.
		/// </summary>
		public const int CopylobbydetailshandlebyinviteidApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyLobbyDetailsHandleByUiEventId" /> API.
		/// </summary>
		public const int CopylobbydetailshandlebyuieventidApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CreateLobby" /> API.
		/// </summary>
		public const int CreatelobbyApiLatest = 9;

		/// <summary>
		/// The most recent version of the <see cref="CreateLobbySearch" /> API.
		/// </summary>
		public const int CreatelobbysearchApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="DestroyLobby" /> API.
		/// </summary>
		public const int DestroylobbyApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetConnectString" /> API.
		/// </summary>
		public const int GetconnectstringApiLatest = 1;

		/// <summary>
		/// The buffer size to provide to the <see cref="GetConnectString" /> API.
		/// </summary>
		public const int GetconnectstringBufferSize = 256;

		/// <summary>
		/// The most recent version of the <see cref="GetInviteCount" /> API.
		/// </summary>
		public const int GetinvitecountApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetInviteIdByIndex" /> API.
		/// </summary>
		public const int GetinviteidbyindexApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetRTCRoomName" /> API.
		/// </summary>
		public const int GetrtcroomnameApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="HardMuteMember" /> API.
		/// </summary>
		public const int HardmutememberApiLatest = 1;

		/// <summary>
		/// Max length of an invite ID
		/// </summary>
		public const int InviteidMaxLength = 64;

		/// <summary>
		/// The most recent version of the <see cref="IsRTCRoomConnected" /> API.
		/// </summary>
		public const int IsrtcroomconnectedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="JoinLobby" /> API.
		/// </summary>
		public const int JoinlobbyApiLatest = 4;

		/// <summary>
		/// The most recent version of the <see cref="JoinLobbyById" /> API.
		/// </summary>
		public const int JoinlobbybyidApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="KickMember" /> API.
		/// </summary>
		public const int KickmemberApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="LeaveLobby" /> API.
		/// </summary>
		public const int LeavelobbyApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="LocalRTCOptions" /> structure.
		/// </summary>
		public const int LocalrtcoptionsApiLatest = 1;

		/// <summary>
		/// All lobbies are referenced by a unique lobby ID
		/// </summary>
		public const int MaxLobbies = 16;

		public const int MaxLobbyMembers = 64;

		/// <summary>
		/// Maximum number of characters allowed in the lobby id override
		/// </summary>
		public const int MaxLobbyidoverrideLength = 60;

		public const int MaxSearchResults = 200;

		/// <summary>
		/// Minimum number of characters allowed in the lobby id override
		/// </summary>
		public const int MinLobbyidoverrideLength = 4;

		/// <summary>
		/// The most recent version of the <see cref="ParseConnectString" /> API.
		/// </summary>
		public const int ParseconnectstringApiLatest = 1;

		/// <summary>
		/// The buffer size to provide to the <see cref="ParseConnectString" /> API.
		/// </summary>
		public const int ParseconnectstringBufferSize = 256;

		/// <summary>
		/// The most recent version of the <see cref="PromoteMember" /> API.
		/// </summary>
		public const int PromotememberApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="QueryInvites" /> API.
		/// </summary>
		public const int QueryinvitesApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="RejectInvite" /> API.
		/// </summary>
		public const int RejectinviteApiLatest = 1;

		/// <summary>
		/// Search for a matching bucket ID (value is string)
		/// </summary>
		public static readonly Utf8String SearchBucketId = "bucket";

		/// <summary>
		/// Search for lobbies that contain at least this number of members (value is int)
		/// </summary>
		public static readonly Utf8String SearchMincurrentmembers = "mincurrentmembers";

		/// <summary>
		/// Search for a match with min free space (value is int)
		/// </summary>
		public static readonly Utf8String SearchMinslotsavailable = "minslotsavailable";

		/// <summary>
		/// The most recent version of the <see cref="SendInvite" /> API.
		/// </summary>
		public const int SendinviteApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UpdateLobby" /> API.
		/// </summary>
		public const int UpdatelobbyApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UpdateLobbyModification" /> API.
		/// </summary>
		public const int UpdatelobbymodificationApiLatest = 1;

		/// <summary>
		/// Register to receive notifications about lobby "JOIN" performed by local user (when no invite) via the overlay.
		/// must call EOS_Lobby_RemoveNotifyJoinLobbyAccepted to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyJoinLobbyAccepted(ref AddNotifyJoinLobbyAcceptedOptions options, object clientData, OnJoinLobbyAcceptedCallback notificationFn)
		{
			AddNotifyJoinLobbyAcceptedOptionsInternal optionsInternal = new AddNotifyJoinLobbyAcceptedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnJoinLobbyAcceptedCallbackInternal(OnJoinLobbyAcceptedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyJoinLobbyAccepted(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications about leave lobby requests performed by the local user via the overlay.
		/// When user requests to leave the lobby in the social overlay, the SDK does not automatically leave the lobby, it is up to the game to perform any necessary cleanup and call the <see cref="LeaveLobby" /> method using the lobbyId sent in the notification function.
		/// must call EOS_Lobby_RemoveNotifyLeaveLobbyRequested to remove the notification.
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLeaveLobbyRequested(ref AddNotifyLeaveLobbyRequestedOptions options, object clientData, OnLeaveLobbyRequestedCallback notificationFn)
		{
			AddNotifyLeaveLobbyRequestedOptionsInternal optionsInternal = new AddNotifyLeaveLobbyRequestedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLeaveLobbyRequestedCallbackInternal(OnLeaveLobbyRequestedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLeaveLobbyRequested(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications about lobby invites accepted by local user via the overlay.
		/// must call RemoveNotifyLobbyInviteAccepted to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLobbyInviteAccepted(ref AddNotifyLobbyInviteAcceptedOptions options, object clientData, OnLobbyInviteAcceptedCallback notificationFn)
		{
			AddNotifyLobbyInviteAcceptedOptionsInternal optionsInternal = new AddNotifyLobbyInviteAcceptedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLobbyInviteAcceptedCallbackInternal(OnLobbyInviteAcceptedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLobbyInviteAccepted(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications about lobby invites sent to local users.
		/// must call RemoveNotifyLobbyInviteReceived to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLobbyInviteReceived(ref AddNotifyLobbyInviteReceivedOptions options, object clientData, OnLobbyInviteReceivedCallback notificationFn)
		{
			AddNotifyLobbyInviteReceivedOptionsInternal optionsInternal = new AddNotifyLobbyInviteReceivedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLobbyInviteReceivedCallbackInternal(OnLobbyInviteReceivedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLobbyInviteReceived(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications about lobby invites rejected by local user.
		/// must call RemoveNotifyLobbyInviteRejected to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLobbyInviteRejected(ref AddNotifyLobbyInviteRejectedOptions options, object clientData, OnLobbyInviteRejectedCallback notificationFn)
		{
			AddNotifyLobbyInviteRejectedOptionsInternal optionsInternal = new AddNotifyLobbyInviteRejectedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLobbyInviteRejectedCallbackInternal(OnLobbyInviteRejectedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLobbyInviteRejected(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications about the changing status of lobby members.
		/// must call RemoveNotifyLobbyMemberStatusReceived to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLobbyMemberStatusReceived(ref AddNotifyLobbyMemberStatusReceivedOptions options, object clientData, OnLobbyMemberStatusReceivedCallback notificationFn)
		{
			AddNotifyLobbyMemberStatusReceivedOptionsInternal optionsInternal = new AddNotifyLobbyMemberStatusReceivedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLobbyMemberStatusReceivedCallbackInternal(OnLobbyMemberStatusReceivedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLobbyMemberStatusReceived(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications when a lobby member updates the attributes associated with themselves inside the lobby.
		/// must call RemoveNotifyLobbyMemberUpdateReceived to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLobbyMemberUpdateReceived(ref AddNotifyLobbyMemberUpdateReceivedOptions options, object clientData, OnLobbyMemberUpdateReceivedCallback notificationFn)
		{
			AddNotifyLobbyMemberUpdateReceivedOptionsInternal optionsInternal = new AddNotifyLobbyMemberUpdateReceivedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLobbyMemberUpdateReceivedCallbackInternal(OnLobbyMemberUpdateReceivedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLobbyMemberUpdateReceived(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications when a lobby owner updates the attributes associated with the lobby.
		/// must call RemoveNotifyLobbyUpdateReceived to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLobbyUpdateReceived(ref AddNotifyLobbyUpdateReceivedOptions options, object clientData, OnLobbyUpdateReceivedCallback notificationFn)
		{
			AddNotifyLobbyUpdateReceivedOptionsInternal optionsInternal = new AddNotifyLobbyUpdateReceivedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLobbyUpdateReceivedCallbackInternal(OnLobbyUpdateReceivedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLobbyUpdateReceived(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications of when the RTC Room for a particular lobby has a connection status change.
		/// 
		/// The RTC Room connection status is independent of the lobby connection status, however the lobby system will attempt to keep
		/// them consistent, automatically connecting to the RTC room after joining a lobby which has an associated RTC room and disconnecting
		/// from the RTC room when a lobby is left or disconnected.
		/// 
		/// This notification is entirely informational and requires no action in response by the application. If the connected status is offline
		/// (bIsConnected is <see langword="false" />), the connection will automatically attempt to reconnect. The purpose of this notification is to allow
		/// applications to show the current connection status of the RTC room when the connection is not established.
		/// 
		/// Unlike <see cref="RTC.RTCInterface.AddNotifyDisconnected" />, <see cref="RTC.RTCInterface.LeaveRoom" /> should not be called when the RTC room is disconnected.
		/// 
		/// This function will only succeed when called on a lobby the local user is currently a member of.
		/// <seealso cref="RemoveNotifyRTCRoomConnectionChanged" />
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to receive updates about</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">The function to call if the RTC Room's connection status changes</param>
		/// <returns>
		/// A valid notification ID if the NotificationFn was successfully registered, or <see cref="Common.InvalidNotificationid" /> if the input was invalid, the lobby did not exist, or the lobby did not have an RTC room.
		/// </returns>
		public ulong AddNotifyRTCRoomConnectionChanged(ref AddNotifyRTCRoomConnectionChangedOptions options, object clientData, OnRTCRoomConnectionChangedCallback notificationFn)
		{
			AddNotifyRTCRoomConnectionChangedOptionsInternal optionsInternal = new AddNotifyRTCRoomConnectionChangedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnRTCRoomConnectionChangedCallbackInternal(OnRTCRoomConnectionChangedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyRTCRoomConnectionChanged(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications about a lobby "INVITE" performed by a local user via the overlay.
		/// This is only needed when a configured integrated platform has <see cref="IntegratedPlatform.IntegratedPlatformManagementFlags.DisableSDKManagedSessions" /> set. The EOS SDK will
		/// then use the state of <see cref="IntegratedPlatform.IntegratedPlatformManagementFlags.PreferEOSIdentity" /> and <see cref="IntegratedPlatform.IntegratedPlatformManagementFlags.PreferIntegratedIdentity" /> to determine when the NotificationFn is
		/// called.
		/// must call EOS_Lobby_RemoveNotifySendLobbyNativeInviteRequested to remove the notification.
		/// <seealso cref="IntegratedPlatform.IntegratedPlatformManagementFlags.DisableSDKManagedSessions" />
		/// <seealso cref="IntegratedPlatform.IntegratedPlatformManagementFlags.PreferEOSIdentity" />
		/// <seealso cref="IntegratedPlatform.IntegratedPlatformManagementFlags.PreferIntegratedIdentity" />
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifySendLobbyNativeInviteRequested(ref AddNotifySendLobbyNativeInviteRequestedOptions options, object clientData, OnSendLobbyNativeInviteRequestedCallback notificationFn)
		{
			AddNotifySendLobbyNativeInviteRequestedOptionsInternal optionsInternal = new AddNotifySendLobbyNativeInviteRequestedOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnSendLobbyNativeInviteRequestedCallbackInternal(OnSendLobbyNativeInviteRequestedCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifySendLobbyNativeInviteRequested(InnerHandle, ref optionsInternal, clientDataAddress, notificationFnInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Create a handle to an existing lobby.
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutLobbyDetailsHandle, must be passed to <see cref="LobbyDetails.Release" /> to release the memory associated with it.
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to retrieve</param>
		/// <param name="outLobbyDetailsHandle">The new active lobby handle or null if there was an error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the lobby handle was created successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> if the lobby doesn't exist
		/// </returns>
		public Result CopyLobbyDetailsHandle(ref CopyLobbyDetailsHandleOptions options, out LobbyDetails outLobbyDetailsHandle)
		{
			CopyLobbyDetailsHandleOptionsInternal optionsInternal = new CopyLobbyDetailsHandleOptionsInternal();
			optionsInternal.Set(ref options);

			var outLobbyDetailsHandleAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Lobby_CopyLobbyDetailsHandle(InnerHandle, ref optionsInternal, ref outLobbyDetailsHandleAddress);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outLobbyDetailsHandleAddress, out outLobbyDetailsHandle);

			return funcResult;
		}

		/// <summary>
		/// <see cref="CopyLobbyDetailsHandleByInviteId" /> is used to immediately retrieve a handle to the lobby information from after notification of an invite
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutLobbyDetailsHandle, must be passed to <see cref="LobbyDetails.Release" /> to release the memory associated with it.
		/// <seealso cref="CopyLobbyDetailsHandleByInviteIdOptions" />
		/// <seealso cref="LobbyDetails.Release" />
		/// </summary>
		/// <param name="options">Structure containing the input parameters</param>
		/// <param name="outLobbyDetailsHandle">out parameter used to receive the lobby handle</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutLobbyDetailsHandle
		/// <see cref="Result.InvalidParameters" /> if you pass an invalid invite ID or a null pointer for the out parameter
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> If the invite ID cannot be found
		/// </returns>
		public Result CopyLobbyDetailsHandleByInviteId(ref CopyLobbyDetailsHandleByInviteIdOptions options, out LobbyDetails outLobbyDetailsHandle)
		{
			CopyLobbyDetailsHandleByInviteIdOptionsInternal optionsInternal = new CopyLobbyDetailsHandleByInviteIdOptionsInternal();
			optionsInternal.Set(ref options);

			var outLobbyDetailsHandleAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Lobby_CopyLobbyDetailsHandleByInviteId(InnerHandle, ref optionsInternal, ref outLobbyDetailsHandleAddress);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outLobbyDetailsHandleAddress, out outLobbyDetailsHandle);

			return funcResult;
		}

		/// <summary>
		/// <see cref="CopyLobbyDetailsHandleByUiEventId" /> is used to immediately retrieve a handle to the lobby information from after notification of an join game
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutLobbyDetailsHandle, must be passed to <see cref="LobbyDetails.Release" /> to release the memory associated with it.
		/// <seealso cref="CopyLobbyDetailsHandleByUiEventIdOptions" />
		/// <seealso cref="LobbyDetails.Release" />
		/// </summary>
		/// <param name="options">Structure containing the input parameters</param>
		/// <param name="outLobbyDetailsHandle">out parameter used to receive the lobby handle</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutLobbyDetailsHandle
		/// <see cref="Result.InvalidParameters" /> if you pass an invalid ui event ID
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> If the invite ID cannot be found
		/// </returns>
		public Result CopyLobbyDetailsHandleByUiEventId(ref CopyLobbyDetailsHandleByUiEventIdOptions options, out LobbyDetails outLobbyDetailsHandle)
		{
			CopyLobbyDetailsHandleByUiEventIdOptionsInternal optionsInternal = new CopyLobbyDetailsHandleByUiEventIdOptionsInternal();
			optionsInternal.Set(ref options);

			var outLobbyDetailsHandleAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Lobby_CopyLobbyDetailsHandleByUiEventId(InnerHandle, ref optionsInternal, ref outLobbyDetailsHandleAddress);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outLobbyDetailsHandleAddress, out outLobbyDetailsHandle);

			return funcResult;
		}

		/// <summary>
		/// Creates a lobby and adds the user to the lobby membership. There is no data associated with the lobby at the start and can be added vis <see cref="UpdateLobbyModification" />
		/// 
		/// If the lobby is successfully created with an RTC Room enabled, the lobby system will automatically join and maintain the connection to the RTC room as long as the
		/// local user remains in the lobby. Applications can use the <see cref="GetRTCRoomName" /> to get the name of the RTC Room associated with a lobby, which may be used with
		/// suite of functions. This can be useful to: register for notifications for talking status; to mute or unmute the local user's audio output;
		/// to block or unblock room participants; to set local audio device settings; and more.
		/// </summary>
		/// <param name="options">Required fields for the creation of a lobby such as a user count and its starting advertised state</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the create operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the creation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.LimitExceeded" /> if the number of allowed lobbies is exceeded
		/// </returns>
		public void CreateLobby(ref CreateLobbyOptions options, object clientData, OnCreateLobbyCallback completionDelegate)
		{
			CreateLobbyOptionsInternal optionsInternal = new CreateLobbyOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnCreateLobbyCallbackInternal(OnCreateLobbyCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_CreateLobby(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Create a lobby search handle. This handle may be modified to include various search parameters.
		/// Searching is possible in three methods, all mutually exclusive
		/// - set the lobby ID to find a specific lobby
		/// - set the target user ID to find a specific user
		/// - set lobby parameters to find an array of lobbies that match the search criteria
		/// </summary>
		/// <param name="options">Structure containing required parameters such as the maximum number of search results</param>
		/// <param name="outLobbySearchHandle">The new search handle or null if there was an error creating the search handle</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the search creation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public Result CreateLobbySearch(ref CreateLobbySearchOptions options, out LobbySearch outLobbySearchHandle)
		{
			CreateLobbySearchOptionsInternal optionsInternal = new CreateLobbySearchOptionsInternal();
			optionsInternal.Set(ref options);

			var outLobbySearchHandleAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Lobby_CreateLobbySearch(InnerHandle, ref optionsInternal, ref outLobbySearchHandleAddress);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outLobbySearchHandleAddress, out outLobbySearchHandle);

			return funcResult;
		}

		/// <summary>
		/// Destroy a lobby given a lobby ID
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to be destroyed</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the destroy operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the destroy completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.AlreadyPending" /> if the lobby is already marked for destroy
		/// <see cref="Result.NotFound" /> if the lobby to be destroyed does not exist
		/// </returns>
		public void DestroyLobby(ref DestroyLobbyOptions options, object clientData, OnDestroyLobbyCallback completionDelegate)
		{
			DestroyLobbyOptionsInternal optionsInternal = new DestroyLobbyOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnDestroyLobbyCallbackInternal(OnDestroyLobbyCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_DestroyLobby(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Get the Connection string for an EOS lobby. The connection string describes the presence of a player in terms of game state.
		/// Xbox platforms expect titles to embed this into their MultiplayerActivity at creation.
		/// When present, the SDK will use this value to populate session presence in the social overlay and facilitate platform invitations.
		/// </summary>
		/// <param name="options">Structure containing the input parameters. API version, the LobbyID of the lobby to generate the string from and the PUID of the requesting user.</param>
		/// <param name="outBuffer">The buffer to store the null-terminated ConnectString within</param>
		/// <param name="inOutBufferLength">In: The maximum amount of writable chars in OutBuffer see <see cref="GetconnectstringBufferSize" />, Out: The minimum amount of chars needed in OutBuffer to store the ConnectString (including the null-terminator). May be set to zero depending on the error result.</param>
		/// <returns>
		/// <see cref="Result.Success" /> if retrieving the string was successful.
		/// <see cref="Result.InvalidParameters" /> if the OutBuffer or InOutBufferLength are null.
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect.
		/// <see cref="Result.NotFound" /> if no lobby is found matching the LobbyID and PUID provided.
		/// <see cref="Result.LimitExceeded" /> if the provided InOutBufferLength is too small to contain the resulting string.
		/// </returns>
		public Result GetConnectString(ref GetConnectStringOptions options, out Utf8String outBuffer)
		{
			GetConnectStringOptionsInternal optionsInternal = new GetConnectStringOptionsInternal();
			optionsInternal.Set(ref options);

			uint inOutBufferLength = GetconnectstringBufferSize;
			System.IntPtr outBufferAddress = Helper.AddAllocation(inOutBufferLength);

			var funcResult = Bindings.EOS_Lobby_GetConnectString(InnerHandle, ref optionsInternal, outBufferAddress, ref inOutBufferLength);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outBufferAddress, out outBuffer);
			Helper.Dispose(ref outBufferAddress);

			return funcResult;
		}

		/// <summary>
		/// Get the number of known invites for a given user
		/// </summary>
		/// <param name="options">the Options associated with retrieving the current invite count</param>
		/// <returns>
		/// number of known invites for a given user or 0 if there is an error
		/// </returns>
		public uint GetInviteCount(ref GetInviteCountOptions options)
		{
			GetInviteCountOptionsInternal optionsInternal = new GetInviteCountOptionsInternal();
			optionsInternal.Set(ref options);

			var funcResult = Bindings.EOS_Lobby_GetInviteCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return funcResult;
		}

		/// <summary>
		/// Retrieve an invite ID from a list of active invites for a given user
		/// <seealso cref="GetInviteCount" />
		/// <seealso cref="CopyLobbyDetailsHandleByInviteId" />
		/// </summary>
		/// <param name="options">Structure containing the input parameters</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the input is valid and an invite ID was returned
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.NotFound" /> if the invite doesn't exist
		/// </returns>
		public Result GetInviteIdByIndex(ref GetInviteIdByIndexOptions options, out Utf8String outBuffer)
		{
			GetInviteIdByIndexOptionsInternal optionsInternal = new GetInviteIdByIndexOptionsInternal();
			optionsInternal.Set(ref options);

			int inOutBufferLength = InviteidMaxLength + 1;
			System.IntPtr outBufferAddress = Helper.AddAllocation(inOutBufferLength);

			var funcResult = Bindings.EOS_Lobby_GetInviteIdByIndex(InnerHandle, ref optionsInternal, outBufferAddress, ref inOutBufferLength);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outBufferAddress, out outBuffer);
			Helper.Dispose(ref outBufferAddress);

			return funcResult;
		}

		/// <summary>
		/// Get the name of the RTC room associated with a specific lobby a local user belongs to.
		/// 
		/// suite of functions. RTC Room Names must not be used with
		/// <see cref="RTC.RTCInterface.JoinRoom" />, <see cref="RTC.RTCInterface.LeaveRoom" />, or <see cref="RTC.RTCInterface.AddNotifyDisconnected" />. Doing so will return <see cref="Result.AccessDenied" /> or
		/// <see cref="Common.InvalidNotificationid" /> if used with those functions.
		/// 
		/// This function will only succeed when called on a lobby the local user is currently a member of.
		/// </summary>
		/// <param name="options">Structure containing information about the RTC room name to retrieve</param>
		/// <param name="outBuffer">The buffer to store the null-terminated room name string within</param>
		/// <param name="inOutBufferLength">In: The maximum amount of writable chars in OutBuffer, Out: The minimum amount of chars needed in OutBuffer to store the RTC room name (including the null-terminator)</param>
		/// <returns>
		/// <see cref="Result.Success" /> if a room exists for the specified lobby, there was enough space in OutBuffer, and the name was written successfully
		/// <see cref="Result.NotFound" /> if the lobby does not exist
		/// <see cref="Result.Disabled" /> if the lobby exists, but did not have the RTC Room feature enabled when created
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer on invalid length for any of the parameters
		/// <see cref="Result.LimitExceeded" /> The OutBuffer is not large enough to receive the room name. InOutBufferLength contains the required minimum length to perform the operation successfully.
		/// </returns>
		public Result GetRTCRoomName(ref GetRTCRoomNameOptions options, out Utf8String outBuffer)
		{
			GetRTCRoomNameOptionsInternal optionsInternal = new GetRTCRoomNameOptionsInternal();
			optionsInternal.Set(ref options);

			uint inOutBufferLength = 256;
			System.IntPtr outBufferAddress = Helper.AddAllocation(inOutBufferLength);

			var funcResult = Bindings.EOS_Lobby_GetRTCRoomName(InnerHandle, ref optionsInternal, outBufferAddress, ref inOutBufferLength);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outBufferAddress, out outBuffer);
			Helper.Dispose(ref outBufferAddress);

			return funcResult;
		}

		/// <summary>
		/// Hard mute an existing member in the lobby, can't speak but can hear other members of the lobby
		/// </summary>
		/// <param name="options">Structure containing information about the lobby and member to be hard muted</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the hard mute operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the hard mute completes successfully
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.InvalidProductUserID" /> if a target user is incorrect
		/// <see cref="Result.NotFound" /> if lobby or target user cannot be found
		/// <see cref="Result.LobbyVoiceNotEnabled" /> if lobby has no voice enabled
		/// <see cref="Result.LobbyNotOwner" /> if the calling user is not the owner of the lobby
		/// <see cref="Result.NotFound" /> if a lobby of interest does not exist
		/// <see cref="Result.AlreadyPending" /> if the user is already marked for hard mute
		/// <see cref="Result.TooManyRequests" /> if there are too many requests
		/// </returns>
		public void HardMuteMember(ref HardMuteMemberOptions options, object clientData, OnHardMuteMemberCallback completionDelegate)
		{
			HardMuteMemberOptionsInternal optionsInternal = new HardMuteMemberOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnHardMuteMemberCallbackInternal(OnHardMuteMemberCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_HardMuteMember(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Get the current connection status of the RTC Room for a lobby.
		/// 
		/// The RTC Room connection status is independent of the lobby connection status, however the lobby system will attempt to keep
		/// them consistent, automatically connecting to the RTC room after joining a lobby which has an associated RTC room and disconnecting
		/// from the RTC room when a lobby is left or disconnected.
		/// 
		/// This function will only succeed when called on a lobby the local user is currently a member of.
		/// <seealso cref="AddNotifyRTCRoomConnectionChanged" />
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to query the RTC Room connection status for</param>
		/// <param name="bOutIsConnected">If the result is <see cref="Result.Success" />, this will be set to <see langword="true" /> if we are connected, or <see langword="false" /> if we are not yet connected.</param>
		/// <returns>
		/// <see cref="Result.Success" /> if we are connected to the specified lobby, the input options and parameters were valid and we were able to write to bOutIsConnected successfully.
		/// <see cref="Result.NotFound" /> if the lobby doesn't exist
		/// <see cref="Result.Disabled" /> if the lobby exists, but did not have the RTC Room feature enabled when created
		/// <see cref="Result.InvalidParameters" /> if bOutIsConnected is <see langword="null" />, or any other parameters are <see langword="null" /> or invalid
		/// </returns>
		public Result IsRTCRoomConnected(ref IsRTCRoomConnectedOptions options, out bool bOutIsConnected)
		{
			IsRTCRoomConnectedOptionsInternal optionsInternal = new IsRTCRoomConnectedOptionsInternal();
			optionsInternal.Set(ref options);

			int bOutIsConnectedInt = 0;

			var funcResult = Bindings.EOS_Lobby_IsRTCRoomConnected(InnerHandle, ref optionsInternal, ref bOutIsConnectedInt);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(bOutIsConnectedInt, out bOutIsConnected);

			return funcResult;
		}

		/// <summary>
		/// Join a lobby, creating a local instance under a given lobby ID. Backend will validate various conditions to make sure it is possible to join the lobby.
		/// 
		/// If the lobby is successfully join has an RTC Room enabled, the lobby system will automatically join and maintain the connection to the RTC room as long as the
		/// local user remains in the lobby. Applications can use the <see cref="GetRTCRoomName" /> to get the name of the RTC Room associated with a lobby, which may be used with
		/// suite of functions. This can be useful to: register for notifications for talking status; to mute or unmute the local user's audio output;
		/// to block or unblock room participants; to set local audio device settings; and more.
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to be joined</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the join operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the destroy completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public void JoinLobby(ref JoinLobbyOptions options, object clientData, OnJoinLobbyCallback completionDelegate)
		{
			JoinLobbyOptionsInternal optionsInternal = new JoinLobbyOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnJoinLobbyCallbackInternal(OnJoinLobbyCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_JoinLobby(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// This is a special case of <see cref="JoinLobby" />. It should only be used if the lobby has had Join-by-ID enabled.
		/// Additionally, Join-by-ID should only be enabled to support native invites on an integrated platform.
		/// <seealso cref="JoinLobby" />
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to be joined</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the join operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the destroy completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public void JoinLobbyById(ref JoinLobbyByIdOptions options, object clientData, OnJoinLobbyByIdCallback completionDelegate)
		{
			JoinLobbyByIdOptionsInternal optionsInternal = new JoinLobbyByIdOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnJoinLobbyByIdCallbackInternal(OnJoinLobbyByIdCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_JoinLobbyById(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Kick an existing member from the lobby
		/// </summary>
		/// <param name="options">Structure containing information about the lobby and member to be kicked</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the kick operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the kick completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.LobbyNotOwner" /> if the calling user is not the owner of the lobby
		/// <see cref="Result.NotFound" /> if a lobby of interest does not exist
		/// </returns>
		public void KickMember(ref KickMemberOptions options, object clientData, OnKickMemberCallback completionDelegate)
		{
			KickMemberOptionsInternal optionsInternal = new KickMemberOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnKickMemberCallbackInternal(OnKickMemberCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_KickMember(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Leave a lobby given a lobby ID
		/// 
		/// If the lobby you are leaving had an RTC Room enabled, leaving the lobby will also automatically leave the RTC room.
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to be left</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the leave operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the leave completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.AlreadyPending" /> if the lobby is already marked for leave
		/// <see cref="Result.NotFound" /> if a lobby to be left does not exist
		/// </returns>
		public void LeaveLobby(ref LeaveLobbyOptions options, object clientData, OnLeaveLobbyCallback completionDelegate)
		{
			LeaveLobbyOptionsInternal optionsInternal = new LeaveLobbyOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnLeaveLobbyCallbackInternal(OnLeaveLobbyCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_LeaveLobby(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Parse the ConnectString for an EOS lobby invitation to extract just the lobby ID.
		/// Used for joining a lobby from a connection string (as generated by GetConnectString) found in a platform invitation or presence.
		/// </summary>
		/// <param name="options">Structure containing the input parameters. API version and ConnectString.</param>
		/// <param name="outBuffer">The buffer to store the null-terminated lobby ID within</param>
		/// <param name="inOutBufferLength">In: The maximum amount of writable chars in OutBuffer see <see cref="ParseconnectstringBufferSize" />, Out: The minimum amount of chars needed in OutBuffer to store the LobbyID (including the null-terminator). May be set to zero depending on the error result.</param>
		/// <returns>
		/// <see cref="Result.Success" /> if retrieving the string was successful.
		/// <see cref="Result.InvalidParameters" /> if the OutBuffer or InOutBufferLength are null.
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect.
		/// <see cref="Result.LimitExceeded" /> if the provided InOutBufferLength is too small to contain the resulting string.
		/// </returns>
		public Result ParseConnectString(ref ParseConnectStringOptions options, out Utf8String outBuffer)
		{
			ParseConnectStringOptionsInternal optionsInternal = new ParseConnectStringOptionsInternal();
			optionsInternal.Set(ref options);

			uint inOutBufferLength = ParseconnectstringBufferSize;
			System.IntPtr outBufferAddress = Helper.AddAllocation(inOutBufferLength);

			var funcResult = Bindings.EOS_Lobby_ParseConnectString(InnerHandle, ref optionsInternal, outBufferAddress, ref inOutBufferLength);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outBufferAddress, out outBuffer);
			Helper.Dispose(ref outBufferAddress);

			return funcResult;
		}

		/// <summary>
		/// Promote an existing member of the lobby to owner, allowing them to make lobby data modifications
		/// </summary>
		/// <param name="options">Structure containing information about the lobby and member to be promoted</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the promotion operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the promote completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.LobbyNotOwner" /> if the calling user is not the owner of the lobby
		/// <see cref="Result.NotFound" /> if the lobby of interest does not exist
		/// </returns>
		public void PromoteMember(ref PromoteMemberOptions options, object clientData, OnPromoteMemberCallback completionDelegate)
		{
			PromoteMemberOptionsInternal optionsInternal = new PromoteMemberOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnPromoteMemberCallbackInternal(OnPromoteMemberCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_PromoteMember(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Retrieve all existing invites for a single user
		/// </summary>
		/// <param name="options">Structure containing information about the invites to query</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the query invites operation completes, either successfully or in error</param>
		public void QueryInvites(ref QueryInvitesOptions options, object clientData, OnQueryInvitesCallback completionDelegate)
		{
			QueryInvitesOptionsInternal optionsInternal = new QueryInvitesOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnQueryInvitesCallbackInternal(OnQueryInvitesCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_QueryInvites(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Reject an invite from another user.
		/// </summary>
		/// <param name="options">Structure containing information about the invite to reject</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the reject invite operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the invite rejection completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.NotFound" /> if the invite does not exist
		/// </returns>
		public void RejectInvite(ref RejectInviteOptions options, object clientData, OnRejectInviteCallback completionDelegate)
		{
			RejectInviteOptionsInternal optionsInternal = new RejectInviteOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnRejectInviteCallbackInternal(OnRejectInviteCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_RejectInvite(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user accepts a lobby invitation via the overlay.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyJoinLobbyAccepted(ulong inId)
		{
			Bindings.EOS_Lobby_RemoveNotifyJoinLobbyAccepted(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user performs a leave lobby action via the overlay.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLeaveLobbyRequested(ulong inId)
		{
			Bindings.EOS_Lobby_RemoveNotifyLeaveLobbyRequested(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user accepts a lobby invitation via the overlay.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLobbyInviteAccepted(ulong inId)
		{
			Bindings.EOS_Lobby_RemoveNotifyLobbyInviteAccepted(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user receives a lobby invitation.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLobbyInviteReceived(ulong inId)
		{
			Bindings.EOS_Lobby_RemoveNotifyLobbyInviteReceived(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user rejects a lobby invitation via the overlay.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLobbyInviteRejected(ulong inId)
		{
			Bindings.EOS_Lobby_RemoveNotifyLobbyInviteRejected(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when lobby members status change.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLobbyMemberStatusReceived(ulong inId)
		{
			Bindings.EOS_Lobby_RemoveNotifyLobbyMemberStatusReceived(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when lobby members change their data.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLobbyMemberUpdateReceived(ulong inId)
		{
			Bindings.EOS_Lobby_RemoveNotifyLobbyMemberUpdateReceived(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a lobby changes its data.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLobbyUpdateReceived(ulong inId)
		{
			Bindings.EOS_Lobby_RemoveNotifyLobbyUpdateReceived(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when an RTC Room's connection status changes.
		/// 
		/// This should be called when the local user is leaving a lobby.
		/// <seealso cref="AddNotifyRTCRoomConnectionChanged" />
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyRTCRoomConnectionChanged(ulong inId)
		{
			Bindings.EOS_Lobby_RemoveNotifyRTCRoomConnectionChanged(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user requests a send invite via the overlay.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifySendLobbyNativeInviteRequested(ulong inId)
		{
			Bindings.EOS_Lobby_RemoveNotifySendLobbyNativeInviteRequested(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Send an invite to another user. User must be a member of the lobby or else the call will fail
		/// </summary>
		/// <param name="options">Structure containing information about the lobby and user to invite</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the send invite operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the send invite completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.NotFound" /> if the lobby to send the invite from does not exist
		/// </returns>
		public void SendInvite(ref SendInviteOptions options, object clientData, OnSendInviteCallback completionDelegate)
		{
			SendInviteOptionsInternal optionsInternal = new SendInviteOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnSendInviteCallbackInternal(OnSendInviteCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_SendInvite(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Update a lobby given a lobby modification handle created by <see cref="UpdateLobbyModification" />
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to be updated</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the update operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the update completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.LobbyNotOwner" /> if the lobby modification contains modifications that are only allowed by the owner
		/// <see cref="Result.NotFound" /> if the lobby to update does not exist
		/// </returns>
		public void UpdateLobby(ref UpdateLobbyOptions options, object clientData, OnUpdateLobbyCallback completionDelegate)
		{
			UpdateLobbyOptionsInternal optionsInternal = new UpdateLobbyOptionsInternal();
			optionsInternal.Set(ref options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnUpdateLobbyCallbackInternal(OnUpdateLobbyCallbackInternalImplementation);
			Helper.AddCallback(out clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_UpdateLobby(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Creates a lobby modification handle (<see cref="LobbyModification" />). The lobby modification handle is used to modify an existing lobby and can be applied with <see cref="UpdateLobby" />.
		/// The <see cref="LobbyModification" /> must be released by calling <see cref="LobbyModification.Release" /> once it is no longer needed.
		/// <seealso cref="LobbyModification.Release" />
		/// <seealso cref="UpdateLobby" />
		/// <seealso cref="LobbyModification" />
		/// </summary>
		/// <param name="options">Required fields such as lobby ID</param>
		/// <param name="outLobbyModificationHandle">Pointer to a Lobby Modification Handle only set if successful</param>
		/// <returns>
		/// <see cref="Result.Success" /> if we successfully created the Lobby Modification Handle pointed at in OutLobbyModificationHandle, or an error result if the input data was invalid
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public Result UpdateLobbyModification(ref UpdateLobbyModificationOptions options, out LobbyModification outLobbyModificationHandle)
		{
			UpdateLobbyModificationOptionsInternal optionsInternal = new UpdateLobbyModificationOptionsInternal();
			optionsInternal.Set(ref options);

			var outLobbyModificationHandleAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Lobby_UpdateLobbyModification(InnerHandle, ref optionsInternal, ref outLobbyModificationHandleAddress);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outLobbyModificationHandleAddress, out outLobbyModificationHandle);

			return funcResult;
		}

		[MonoPInvokeCallback(typeof(OnCreateLobbyCallbackInternal))]
		internal static void OnCreateLobbyCallbackInternalImplementation(ref CreateLobbyCallbackInfoInternal data)
		{
			OnCreateLobbyCallback callback;
			CreateLobbyCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnDestroyLobbyCallbackInternal))]
		internal static void OnDestroyLobbyCallbackInternalImplementation(ref DestroyLobbyCallbackInfoInternal data)
		{
			OnDestroyLobbyCallback callback;
			DestroyLobbyCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnHardMuteMemberCallbackInternal))]
		internal static void OnHardMuteMemberCallbackInternalImplementation(ref HardMuteMemberCallbackInfoInternal data)
		{
			OnHardMuteMemberCallback callback;
			HardMuteMemberCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnJoinLobbyAcceptedCallbackInternal))]
		internal static void OnJoinLobbyAcceptedCallbackInternalImplementation(ref JoinLobbyAcceptedCallbackInfoInternal data)
		{
			OnJoinLobbyAcceptedCallback callback;
			JoinLobbyAcceptedCallbackInfo callbackInfo;
			if (Helper.TryGetCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnJoinLobbyByIdCallbackInternal))]
		internal static void OnJoinLobbyByIdCallbackInternalImplementation(ref JoinLobbyByIdCallbackInfoInternal data)
		{
			OnJoinLobbyByIdCallback callback;
			JoinLobbyByIdCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnJoinLobbyCallbackInternal))]
		internal static void OnJoinLobbyCallbackInternalImplementation(ref JoinLobbyCallbackInfoInternal data)
		{
			OnJoinLobbyCallback callback;
			JoinLobbyCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnKickMemberCallbackInternal))]
		internal static void OnKickMemberCallbackInternalImplementation(ref KickMemberCallbackInfoInternal data)
		{
			OnKickMemberCallback callback;
			KickMemberCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLeaveLobbyCallbackInternal))]
		internal static void OnLeaveLobbyCallbackInternalImplementation(ref LeaveLobbyCallbackInfoInternal data)
		{
			OnLeaveLobbyCallback callback;
			LeaveLobbyCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLeaveLobbyRequestedCallbackInternal))]
		internal static void OnLeaveLobbyRequestedCallbackInternalImplementation(ref LeaveLobbyRequestedCallbackInfoInternal data)
		{
			OnLeaveLobbyRequestedCallback callback;
			LeaveLobbyRequestedCallbackInfo callbackInfo;
			if (Helper.TryGetCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLobbyInviteAcceptedCallbackInternal))]
		internal static void OnLobbyInviteAcceptedCallbackInternalImplementation(ref LobbyInviteAcceptedCallbackInfoInternal data)
		{
			OnLobbyInviteAcceptedCallback callback;
			LobbyInviteAcceptedCallbackInfo callbackInfo;
			if (Helper.TryGetCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLobbyInviteReceivedCallbackInternal))]
		internal static void OnLobbyInviteReceivedCallbackInternalImplementation(ref LobbyInviteReceivedCallbackInfoInternal data)
		{
			OnLobbyInviteReceivedCallback callback;
			LobbyInviteReceivedCallbackInfo callbackInfo;
			if (Helper.TryGetCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLobbyInviteRejectedCallbackInternal))]
		internal static void OnLobbyInviteRejectedCallbackInternalImplementation(ref LobbyInviteRejectedCallbackInfoInternal data)
		{
			OnLobbyInviteRejectedCallback callback;
			LobbyInviteRejectedCallbackInfo callbackInfo;
			if (Helper.TryGetCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLobbyMemberStatusReceivedCallbackInternal))]
		internal static void OnLobbyMemberStatusReceivedCallbackInternalImplementation(ref LobbyMemberStatusReceivedCallbackInfoInternal data)
		{
			OnLobbyMemberStatusReceivedCallback callback;
			LobbyMemberStatusReceivedCallbackInfo callbackInfo;
			if (Helper.TryGetCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLobbyMemberUpdateReceivedCallbackInternal))]
		internal static void OnLobbyMemberUpdateReceivedCallbackInternalImplementation(ref LobbyMemberUpdateReceivedCallbackInfoInternal data)
		{
			OnLobbyMemberUpdateReceivedCallback callback;
			LobbyMemberUpdateReceivedCallbackInfo callbackInfo;
			if (Helper.TryGetCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLobbyUpdateReceivedCallbackInternal))]
		internal static void OnLobbyUpdateReceivedCallbackInternalImplementation(ref LobbyUpdateReceivedCallbackInfoInternal data)
		{
			OnLobbyUpdateReceivedCallback callback;
			LobbyUpdateReceivedCallbackInfo callbackInfo;
			if (Helper.TryGetCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnPromoteMemberCallbackInternal))]
		internal static void OnPromoteMemberCallbackInternalImplementation(ref PromoteMemberCallbackInfoInternal data)
		{
			OnPromoteMemberCallback callback;
			PromoteMemberCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnQueryInvitesCallbackInternal))]
		internal static void OnQueryInvitesCallbackInternalImplementation(ref QueryInvitesCallbackInfoInternal data)
		{
			OnQueryInvitesCallback callback;
			QueryInvitesCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnRTCRoomConnectionChangedCallbackInternal))]
		internal static void OnRTCRoomConnectionChangedCallbackInternalImplementation(ref RTCRoomConnectionChangedCallbackInfoInternal data)
		{
			OnRTCRoomConnectionChangedCallback callback;
			RTCRoomConnectionChangedCallbackInfo callbackInfo;
			if (Helper.TryGetCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnRejectInviteCallbackInternal))]
		internal static void OnRejectInviteCallbackInternalImplementation(ref RejectInviteCallbackInfoInternal data)
		{
			OnRejectInviteCallback callback;
			RejectInviteCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnSendInviteCallbackInternal))]
		internal static void OnSendInviteCallbackInternalImplementation(ref SendInviteCallbackInfoInternal data)
		{
			OnSendInviteCallback callback;
			SendInviteCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnSendLobbyNativeInviteRequestedCallbackInternal))]
		internal static void OnSendLobbyNativeInviteRequestedCallbackInternalImplementation(ref SendLobbyNativeInviteRequestedCallbackInfoInternal data)
		{
			OnSendLobbyNativeInviteRequestedCallback callback;
			SendLobbyNativeInviteRequestedCallbackInfo callbackInfo;
			if (Helper.TryGetCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnUpdateLobbyCallbackInternal))]
		internal static void OnUpdateLobbyCallbackInternalImplementation(ref UpdateLobbyCallbackInfoInternal data)
		{
			OnUpdateLobbyCallback callback;
			UpdateLobbyCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback(ref data, out callback, out callbackInfo))
			{
				callback(ref callbackInfo);
			}
		}
	}
}