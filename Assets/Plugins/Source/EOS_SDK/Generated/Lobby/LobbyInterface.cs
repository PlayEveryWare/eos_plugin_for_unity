// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.Lobby
{
	public sealed partial class LobbyInterface : Handle
	{
		public LobbyInterface()
		{
		}

		public LobbyInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyJoinLobbyAccepted" /> API.
		/// </summary>
		public const int AddnotifyjoinlobbyacceptedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLobbyInviteAccepted" /> API.
		/// </summary>
		public const int AddnotifylobbyinviteacceptedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLobbyInviteReceived" /> API.
		/// </summary>
		public const int AddnotifylobbyinvitereceivedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLobbyMemberStatusReceived" /> API.
		/// </summary>
		public const int AddnotifylobbymemberstatusreceivedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLobbyMemberUpdateReceived" /> API.
		/// </summary>
		public const int AddnotifylobbymemberupdatereceivedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLobbyUpdateReceived" /> API.
		/// </summary>
		public const int AddnotifylobbyupdatereceivedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyRTCRoomConnectionChanged" /> API.
		/// </summary>
		public const int AddnotifyrtcroomconnectionchangedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="Attribute" /> struct.
		/// </summary>
		public const int AttributeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AttributeData" /> struct.
		/// </summary>
		public const int AttributedataApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyLobbyDetailsHandle" /> API.
		/// </summary>
		public const int CopylobbydetailshandleApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyLobbyDetailsHandleByInviteId" /> API.
		/// </summary>
		public const int CopylobbydetailshandlebyinviteidApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyLobbyDetailsHandleByUiEventId" /> API.
		/// </summary>
		public const int CopylobbydetailshandlebyuieventidApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CreateLobby" /> API.
		/// </summary>
		public const int CreatelobbyApiLatest = 7;

		/// <summary>
		/// The most recent version of the <see cref="CreateLobbySearch" /> API.
		/// </summary>
		public const int CreatelobbysearchApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="DestroyLobby" /> API.
		/// </summary>
		public const int DestroylobbyApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetInviteCount" /> API.
		/// </summary>
		public const int GetinvitecountApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetInviteIdByIndex" /> API.
		/// </summary>
		public const int GetinviteidbyindexApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetRTCRoomName" /> API.
		/// </summary>
		public const int GetrtcroomnameApiLatest = 1;

		/// <summary>
		/// Max length of an invite ID
		/// </summary>
		public const int InviteidMaxLength = 64;

		/// <summary>
		/// The most recent version of the <see cref="IsRTCRoomConnected" /> API.
		/// </summary>
		public const int IsrtcroomconnectedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="JoinLobby" /> API.
		/// </summary>
		public const int JoinlobbyApiLatest = 3;

		/// <summary>
		/// The most recent version of the <see cref="KickMember" /> API.
		/// </summary>
		public const int KickmemberApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="LeaveLobby" /> API.
		/// </summary>
		public const int LeavelobbyApiLatest = 1;

		public const int LocalrtcoptionsApiLatest = 1;

		/// <summary>
		/// All lobbies are referenced by a unique lobby ID
		/// </summary>
		public const int MaxLobbies = 16;

		public const int MaxLobbyMembers = 64;

		/// <summary>
		/// Maximum number of characters allowed in the lobby id override
		/// </summary>
		public const int MaxLobbyidoverrideLength = 60;

		public const int MaxSearchResults = 200;

		/// <summary>
		/// Minimum number of characters allowed in the lobby id override
		/// </summary>
		public const int MinLobbyidoverrideLength = 4;

		/// <summary>
		/// The most recent version of the <see cref="PromoteMember" /> API.
		/// </summary>
		public const int PromotememberApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="QueryInvites" /> API.
		/// </summary>
		public const int QueryinvitesApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="RejectInvite" /> API.
		/// </summary>
		public const int RejectinviteApiLatest = 1;

		/// <summary>
		/// Search for a matching bucket ID (value is string)
		/// </summary>
		public const string SearchBucketId = "bucket";

		/// <summary>
		/// Search for lobbies that contain at least this number of members (value is int)
		/// </summary>
		public const string SearchMincurrentmembers = "mincurrentmembers";

		/// <summary>
		/// Search for a match with min free space (value is int)
		/// </summary>
		public const string SearchMinslotsavailable = "minslotsavailable";

		/// <summary>
		/// The most recent version of the <see cref="SendInvite" /> API.
		/// </summary>
		public const int SendinviteApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UpdateLobby" /> API.
		/// </summary>
		public const int UpdatelobbyApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UpdateLobbyModification" /> API.
		/// </summary>
		public const int UpdatelobbymodificationApiLatest = 1;

		/// <summary>
		/// Register to receive notifications about lobby join game accepted by local user via the overlay.
		/// @note must call <see cref="RemoveNotifyJoinLobbyAccepted" /> to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyJoinLobbyAccepted(AddNotifyJoinLobbyAcceptedOptions options, object clientData, OnJoinLobbyAcceptedCallback notificationFn)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyJoinLobbyAcceptedOptionsInternal, AddNotifyJoinLobbyAcceptedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnJoinLobbyAcceptedCallbackInternal(OnJoinLobbyAcceptedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyJoinLobbyAccepted(InnerHandle, optionsAddress, clientDataAddress, notificationFnInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications about lobby invites accepted by local user via the overlay.
		/// @note must call RemoveNotifyLobbyInviteAccepted to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLobbyInviteAccepted(AddNotifyLobbyInviteAcceptedOptions options, object clientData, OnLobbyInviteAcceptedCallback notificationFn)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyLobbyInviteAcceptedOptionsInternal, AddNotifyLobbyInviteAcceptedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLobbyInviteAcceptedCallbackInternal(OnLobbyInviteAcceptedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLobbyInviteAccepted(InnerHandle, optionsAddress, clientDataAddress, notificationFnInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications about lobby invites sent to local users.
		/// @note must call RemoveNotifyLobbyInviteReceived to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLobbyInviteReceived(AddNotifyLobbyInviteReceivedOptions options, object clientData, OnLobbyInviteReceivedCallback notificationFn)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyLobbyInviteReceivedOptionsInternal, AddNotifyLobbyInviteReceivedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLobbyInviteReceivedCallbackInternal(OnLobbyInviteReceivedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLobbyInviteReceived(InnerHandle, optionsAddress, clientDataAddress, notificationFnInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications about the changing status of lobby members.
		/// @note must call RemoveNotifyLobbyMemberStatusReceived to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLobbyMemberStatusReceived(AddNotifyLobbyMemberStatusReceivedOptions options, object clientData, OnLobbyMemberStatusReceivedCallback notificationFn)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyLobbyMemberStatusReceivedOptionsInternal, AddNotifyLobbyMemberStatusReceivedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLobbyMemberStatusReceivedCallbackInternal(OnLobbyMemberStatusReceivedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLobbyMemberStatusReceived(InnerHandle, optionsAddress, clientDataAddress, notificationFnInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications when a lobby member updates the attributes associated with themselves inside the lobby.
		/// @note must call RemoveNotifyLobbyMemberUpdateReceived to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLobbyMemberUpdateReceived(AddNotifyLobbyMemberUpdateReceivedOptions options, object clientData, OnLobbyMemberUpdateReceivedCallback notificationFn)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyLobbyMemberUpdateReceivedOptionsInternal, AddNotifyLobbyMemberUpdateReceivedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLobbyMemberUpdateReceivedCallbackInternal(OnLobbyMemberUpdateReceivedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLobbyMemberUpdateReceived(InnerHandle, optionsAddress, clientDataAddress, notificationFnInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications when a lobby owner updates the attributes associated with the lobby.
		/// @note must call RemoveNotifyLobbyUpdateReceived to remove the notification
		/// </summary>
		/// <param name="options">Structure containing information about the request.</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">A callback that is fired when a a notification is received.</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLobbyUpdateReceived(AddNotifyLobbyUpdateReceivedOptions options, object clientData, OnLobbyUpdateReceivedCallback notificationFn)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyLobbyUpdateReceivedOptionsInternal, AddNotifyLobbyUpdateReceivedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnLobbyUpdateReceivedCallbackInternal(OnLobbyUpdateReceivedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyLobbyUpdateReceived(InnerHandle, optionsAddress, clientDataAddress, notificationFnInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Register to receive notifications of when the RTC Room for a particular lobby has a connection status change.
		/// 
		/// The RTC Room connection status is independent of the lobby connection status, however the lobby system will attempt to keep
		/// them consistent, automatically connecting to the RTC room after joining a lobby which has an associated RTC room and disconnecting
		/// from the RTC room when a lobby is left or disconnected.
		/// 
		/// This notification is entirely informational and requires no action in response by the application. If the connected status is offline
		/// (bIsConnected is false), the connection will automatically attempt to reconnect. The purpose of this notification is to allow
		/// applications to show the current connection status of the RTC room when the connection is not established.
		/// 
		/// Unlike <see cref="RTC.RTCInterface.AddNotifyDisconnected" />, <see cref="RTC.RTCInterface.LeaveRoom" /> should not be called when the RTC room is disconnected.
		/// 
		/// This function will only succeed when called on a lobby the local user is currently a member of.
		/// <seealso cref="RemoveNotifyRTCRoomConnectionChanged" />
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to receive updates about</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate.</param>
		/// <param name="notificationFn">The function to call if the RTC Room's connection status changes</param>
		/// <returns>
		/// A valid notification ID if the NotificationFn was successfully registered, or <see cref="Common.InvalidNotificationid" /> if the input was invalid, the lobby did not exist, or the lobby did not have an RTC room.
		/// </returns>
		public ulong AddNotifyRTCRoomConnectionChanged(AddNotifyRTCRoomConnectionChangedOptions options, object clientData, OnRTCRoomConnectionChangedCallback notificationFn)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyRTCRoomConnectionChangedOptionsInternal, AddNotifyRTCRoomConnectionChangedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var notificationFnInternal = new OnRTCRoomConnectionChangedCallbackInternal(OnRTCRoomConnectionChangedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, notificationFn, notificationFnInternal);

			var funcResult = Bindings.EOS_Lobby_AddNotifyRTCRoomConnectionChanged(InnerHandle, optionsAddress, clientDataAddress, notificationFnInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Create a handle to an existing lobby.
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutLobbyDetailsHandle, must be passed to <see cref="LobbyDetails.Release" /> to release the memory associated with it.
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to retrieve</param>
		/// <param name="outLobbyDetailsHandle">The new active lobby handle or null if there was an error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the lobby handle was created successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> if the lobby doesn't exist
		/// </returns>
		public Result CopyLobbyDetailsHandle(CopyLobbyDetailsHandleOptions options, out LobbyDetails outLobbyDetailsHandle)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyLobbyDetailsHandleOptionsInternal, CopyLobbyDetailsHandleOptions>(ref optionsAddress, options);

			var outLobbyDetailsHandleAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Lobby_CopyLobbyDetailsHandle(InnerHandle, optionsAddress, ref outLobbyDetailsHandleAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outLobbyDetailsHandleAddress, out outLobbyDetailsHandle);

			return funcResult;
		}

		/// <summary>
		/// <see cref="CopyLobbyDetailsHandleByInviteId" /> is used to immediately retrieve a handle to the lobby information from after notification of an invite
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutLobbyDetailsHandle, must be passed to <see cref="LobbyDetails.Release" /> to release the memory associated with it.
		/// <seealso cref="CopyLobbyDetailsHandleByInviteIdOptions" />
		/// <seealso cref="LobbyDetails.Release" />
		/// </summary>
		/// <param name="options">Structure containing the input parameters</param>
		/// <param name="outLobbyDetailsHandle">out parameter used to receive the lobby handle</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutLobbyDetailsHandle
		/// <see cref="Result.InvalidParameters" /> if you pass an invalid invite ID or a null pointer for the out parameter
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> If the invite ID cannot be found
		/// </returns>
		public Result CopyLobbyDetailsHandleByInviteId(CopyLobbyDetailsHandleByInviteIdOptions options, out LobbyDetails outLobbyDetailsHandle)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyLobbyDetailsHandleByInviteIdOptionsInternal, CopyLobbyDetailsHandleByInviteIdOptions>(ref optionsAddress, options);

			var outLobbyDetailsHandleAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Lobby_CopyLobbyDetailsHandleByInviteId(InnerHandle, optionsAddress, ref outLobbyDetailsHandleAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outLobbyDetailsHandleAddress, out outLobbyDetailsHandle);

			return funcResult;
		}

		/// <summary>
		/// <see cref="CopyLobbyDetailsHandleByUiEventId" /> is used to immediately retrieve a handle to the lobby information from after notification of an join game
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutLobbyDetailsHandle, must be passed to <see cref="LobbyDetails.Release" /> to release the memory associated with it.
		/// <seealso cref="CopyLobbyDetailsHandleByUiEventIdOptions" />
		/// <seealso cref="LobbyDetails.Release" />
		/// </summary>
		/// <param name="options">Structure containing the input parameters</param>
		/// <param name="outLobbyDetailsHandle">out parameter used to receive the lobby handle</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutLobbyDetailsHandle
		/// <see cref="Result.InvalidParameters" /> if you pass an invalid ui event ID
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> If the invite ID cannot be found
		/// </returns>
		public Result CopyLobbyDetailsHandleByUiEventId(CopyLobbyDetailsHandleByUiEventIdOptions options, out LobbyDetails outLobbyDetailsHandle)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CopyLobbyDetailsHandleByUiEventIdOptionsInternal, CopyLobbyDetailsHandleByUiEventIdOptions>(ref optionsAddress, options);

			var outLobbyDetailsHandleAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Lobby_CopyLobbyDetailsHandleByUiEventId(InnerHandle, optionsAddress, ref outLobbyDetailsHandleAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outLobbyDetailsHandleAddress, out outLobbyDetailsHandle);

			return funcResult;
		}

		/// <summary>
		/// Creates a lobby and adds the user to the lobby membership. There is no data associated with the lobby at the start and can be added vis <see cref="UpdateLobbyModification" />
		/// 
		/// If the lobby is successfully created with an RTC Room enabled, the lobby system will automatically join and maintain the connection to the RTC room as long as the
		/// local user remains in the lobby. Applications can use the <see cref="GetRTCRoomName" /> to get the name of the RTC Room associated with a lobby, which may be used with
		/// suite of functions. This can be useful to: register for notifications for talking status; to mute or unmute the local user's audio output;
		/// to block or unblock room participants; to set local audio device settings; and more.
		/// </summary>
		/// <param name="options">Required fields for the creation of a lobby such as a user count and its starting advertised state</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the create operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the creation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.LimitExceeded" /> if the number of allowed lobbies is exceeded
		/// </returns>
		public void CreateLobby(CreateLobbyOptions options, object clientData, OnCreateLobbyCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CreateLobbyOptionsInternal, CreateLobbyOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnCreateLobbyCallbackInternal(OnCreateLobbyCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_CreateLobby(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Create a lobby search handle. This handle may be modified to include various search parameters.
		/// Searching is possible in three methods, all mutually exclusive
		/// - set the lobby ID to find a specific lobby
		/// - set the target user ID to find a specific user
		/// - set lobby parameters to find an array of lobbies that match the search criteria (not available yet)
		/// </summary>
		/// <param name="options">Structure containing required parameters such as the maximum number of search results</param>
		/// <param name="outLobbySearchHandle">The new search handle or null if there was an error creating the search handle</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the search creation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public Result CreateLobbySearch(CreateLobbySearchOptions options, out LobbySearch outLobbySearchHandle)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CreateLobbySearchOptionsInternal, CreateLobbySearchOptions>(ref optionsAddress, options);

			var outLobbySearchHandleAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Lobby_CreateLobbySearch(InnerHandle, optionsAddress, ref outLobbySearchHandleAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outLobbySearchHandleAddress, out outLobbySearchHandle);

			return funcResult;
		}

		/// <summary>
		/// Destroy a lobby given a lobby ID
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to be destroyed</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the destroy operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the destroy completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.AlreadyPending" /> if the lobby is already marked for destroy
		/// <see cref="Result.NotFound" /> if the lobby to be destroyed does not exist
		/// </returns>
		public void DestroyLobby(DestroyLobbyOptions options, object clientData, OnDestroyLobbyCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<DestroyLobbyOptionsInternal, DestroyLobbyOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnDestroyLobbyCallbackInternal(OnDestroyLobbyCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_DestroyLobby(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Get the number of known invites for a given user
		/// </summary>
		/// <param name="options">the Options associated with retrieving the current invite count</param>
		/// <returns>
		/// number of known invites for a given user or 0 if there is an error
		/// </returns>
		public uint GetInviteCount(GetInviteCountOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetInviteCountOptionsInternal, GetInviteCountOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_Lobby_GetInviteCount(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Retrieve an invite ID from a list of active invites for a given user
		/// <seealso cref="GetInviteCount" />
		/// <seealso cref="CopyLobbyDetailsHandleByInviteId" />
		/// </summary>
		/// <param name="options">Structure containing the input parameters</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the input is valid and an invite ID was returned
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.NotFound" /> if the invite doesn't exist
		/// </returns>
		public Result GetInviteIdByIndex(GetInviteIdByIndexOptions options, out string outBuffer)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetInviteIdByIndexOptionsInternal, GetInviteIdByIndexOptions>(ref optionsAddress, options);

			System.IntPtr outBufferAddress = System.IntPtr.Zero;
			int inOutBufferLength = InviteidMaxLength + 1;
			Helper.TryMarshalAllocate(ref outBufferAddress, inOutBufferLength, out _);

			var funcResult = Bindings.EOS_Lobby_GetInviteIdByIndex(InnerHandle, optionsAddress, outBufferAddress, ref inOutBufferLength);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outBufferAddress, out outBuffer);
			Helper.TryMarshalDispose(ref outBufferAddress);

			return funcResult;
		}

		/// <summary>
		/// Get the name of the RTC room associated with a specific lobby a local user belongs to.
		/// 
		/// suite of functions. RTC Room Names must not be used with
		/// <see cref="RTC.RTCInterface.JoinRoom" />, <see cref="RTC.RTCInterface.LeaveRoom" />, or <see cref="RTC.RTCInterface.AddNotifyDisconnected" />. Doing so will return <see cref="Result.AccessDenied" /> or
		/// <see cref="Common.InvalidNotificationid" /> if used with those functions.
		/// 
		/// This function will only succeed when called on a lobby the local user is currently a member of.
		/// </summary>
		/// <param name="options">Structure containing information about the RTC room name to retrieve</param>
		/// <param name="outBuffer">The buffer to store the null-terminated room name string within</param>
		/// <param name="inOutBufferLength">In: The maximum amount of writable chars in OutBuffer, Out: The minimum amount of chars needed in OutBuffer to store the RTC room name (including the null-terminator)</param>
		/// <returns>
		/// <see cref="Result.Success" /> if a room exists for the specified lobby, there was enough space in OutBuffer, and the name was written successfully
		/// <see cref="Result.NotFound" /> if the lobby does not exist
		/// <see cref="Result.Disabled" /> if the lobby exists, but did not have the RTC Room feature enabled when created
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer on invalid length for any of the parameters
		/// <see cref="Result.LimitExceeded" /> The OutBuffer is not large enough to receive the room name. InOutBufferLength contains the required minimum length to perform the operation successfully.
		/// </returns>
		public Result GetRTCRoomName(GetRTCRoomNameOptions options, out string outBuffer)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetRTCRoomNameOptionsInternal, GetRTCRoomNameOptions>(ref optionsAddress, options);

			System.IntPtr outBufferAddress = System.IntPtr.Zero;
			uint inOutBufferLength = 256;
			Helper.TryMarshalAllocate(ref outBufferAddress, inOutBufferLength, out _);

			var funcResult = Bindings.EOS_Lobby_GetRTCRoomName(InnerHandle, optionsAddress, outBufferAddress, ref inOutBufferLength);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outBufferAddress, out outBuffer);
			Helper.TryMarshalDispose(ref outBufferAddress);

			return funcResult;
		}

		/// <summary>
		/// Get the current connection status of the RTC Room for a lobby.
		/// 
		/// The RTC Room connection status is independent of the lobby connection status, however the lobby system will attempt to keep
		/// them consistent, automatically connecting to the RTC room after joining a lobby which has an associated RTC room and disconnecting
		/// from the RTC room when a lobby is left or disconnected.
		/// 
		/// This function will only succeed when called on a lobby the local user is currently a member of.
		/// <seealso cref="AddNotifyRTCRoomConnectionChanged" />
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to query the RTC Room connection status for</param>
		/// <param name="bOutIsConnected">If the result is <see cref="Result.Success" />, this will be set to true if we are connected, or false if we are not yet connected.</param>
		/// <returns>
		/// <see cref="Result.Success" /> if we are connected to the specified lobby, the input options and parameters were valid and we were able to write to bOutIsConnected successfully.
		/// <see cref="Result.NotFound" /> if the lobby doesn't exist
		/// <see cref="Result.Disabled" /> if the lobby exists, but did not have the RTC Room feature enabled when created
		/// <see cref="Result.InvalidParameters" /> if bOutIsConnected is NULL, or any other parameters are NULL or invalid
		/// </returns>
		public Result IsRTCRoomConnected(IsRTCRoomConnectedOptions options, out bool bOutIsConnected)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<IsRTCRoomConnectedOptionsInternal, IsRTCRoomConnectedOptions>(ref optionsAddress, options);

			int bOutIsConnectedInt = 0;

			var funcResult = Bindings.EOS_Lobby_IsRTCRoomConnected(InnerHandle, optionsAddress, ref bOutIsConnectedInt);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(bOutIsConnectedInt, out bOutIsConnected);

			return funcResult;
		}

		/// <summary>
		/// Join a lobby, creating a local instance under a given lobby ID. Backend will validate various conditions to make sure it is possible to join the lobby.
		/// 
		/// If the lobby is successfully join has an RTC Room enabled, the lobby system will automatically join and maintain the connection to the RTC room as long as the
		/// local user remains in the lobby. Applications can use the <see cref="GetRTCRoomName" /> to get the name of the RTC Room associated with a lobby, which may be used with
		/// suite of functions. This can be useful to: register for notifications for talking status; to mute or unmute the local user's audio output;
		/// to block or unblock room participants; to set local audio device settings; and more.
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to be joined</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the join operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the destroy completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public void JoinLobby(JoinLobbyOptions options, object clientData, OnJoinLobbyCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<JoinLobbyOptionsInternal, JoinLobbyOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnJoinLobbyCallbackInternal(OnJoinLobbyCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_JoinLobby(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Kick an existing member from the lobby
		/// </summary>
		/// <param name="options">Structure containing information about the lobby and member to be kicked</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the kick operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the kick completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.LobbyNotOwner" /> if the calling user is not the owner of the lobby
		/// <see cref="Result.NotFound" /> if a lobby of interest does not exist
		/// </returns>
		public void KickMember(KickMemberOptions options, object clientData, OnKickMemberCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<KickMemberOptionsInternal, KickMemberOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnKickMemberCallbackInternal(OnKickMemberCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_KickMember(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Leave a lobby given a lobby ID
		/// 
		/// If the lobby you are leaving had an RTC Room enabled, leaving the lobby will also automatically leave the RTC room.
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to be left</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the leave operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the leave completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.AlreadyPending" /> if the lobby is already marked for leave
		/// <see cref="Result.NotFound" /> if a lobby to be left does not exist
		/// </returns>
		public void LeaveLobby(LeaveLobbyOptions options, object clientData, OnLeaveLobbyCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<LeaveLobbyOptionsInternal, LeaveLobbyOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnLeaveLobbyCallbackInternal(OnLeaveLobbyCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_LeaveLobby(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Promote an existing member of the lobby to owner, allowing them to make lobby data modifications
		/// </summary>
		/// <param name="options">Structure containing information about the lobby and member to be promoted</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the promotion operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the promote completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.LobbyNotOwner" /> if the calling user is not the owner of the lobby
		/// <see cref="Result.NotFound" /> if the lobby of interest does not exist
		/// </returns>
		public void PromoteMember(PromoteMemberOptions options, object clientData, OnPromoteMemberCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<PromoteMemberOptionsInternal, PromoteMemberOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnPromoteMemberCallbackInternal(OnPromoteMemberCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_PromoteMember(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Retrieve all existing invites for a single user
		/// </summary>
		/// <param name="options">Structure containing information about the invites to query</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the query invites operation completes, either successfully or in error</param>
		public void QueryInvites(QueryInvitesOptions options, object clientData, OnQueryInvitesCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<QueryInvitesOptionsInternal, QueryInvitesOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnQueryInvitesCallbackInternal(OnQueryInvitesCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_QueryInvites(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Reject an invite from another user.
		/// </summary>
		/// <param name="options">Structure containing information about the invite to reject</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the reject invite operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the invite rejection completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.NotFound" /> if the invite does not exist
		/// </returns>
		public void RejectInvite(RejectInviteOptions options, object clientData, OnRejectInviteCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<RejectInviteOptionsInternal, RejectInviteOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnRejectInviteCallbackInternal(OnRejectInviteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_RejectInvite(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user accepts a lobby invitation via the overlay.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyJoinLobbyAccepted(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);

			Bindings.EOS_Lobby_RemoveNotifyJoinLobbyAccepted(InnerHandle, inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user accepts a lobby invitation via the overlay.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLobbyInviteAccepted(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);

			Bindings.EOS_Lobby_RemoveNotifyLobbyInviteAccepted(InnerHandle, inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user receives a lobby invitation.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLobbyInviteReceived(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);

			Bindings.EOS_Lobby_RemoveNotifyLobbyInviteReceived(InnerHandle, inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when lobby members status change.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLobbyMemberStatusReceived(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);

			Bindings.EOS_Lobby_RemoveNotifyLobbyMemberStatusReceived(InnerHandle, inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when lobby members change their data.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLobbyMemberUpdateReceived(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);

			Bindings.EOS_Lobby_RemoveNotifyLobbyMemberUpdateReceived(InnerHandle, inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a lobby changes its data.
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyLobbyUpdateReceived(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);

			Bindings.EOS_Lobby_RemoveNotifyLobbyUpdateReceived(InnerHandle, inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when an RTC Room's connection status changes.
		/// 
		/// This should be called when the local user is leaving a lobby.
		/// <seealso cref="AddNotifyRTCRoomConnectionChanged" />
		/// </summary>
		/// <param name="inId">Handle representing the registered callback</param>
		public void RemoveNotifyRTCRoomConnectionChanged(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);

			Bindings.EOS_Lobby_RemoveNotifyRTCRoomConnectionChanged(InnerHandle, inId);
		}

		/// <summary>
		/// Send an invite to another user. User must be a member of the lobby or else the call will fail
		/// </summary>
		/// <param name="options">Structure containing information about the lobby and user to invite</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the send invite operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the send invite completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.NotFound" /> if the lobby to send the invite from does not exist
		/// </returns>
		public void SendInvite(SendInviteOptions options, object clientData, OnSendInviteCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<SendInviteOptionsInternal, SendInviteOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnSendInviteCallbackInternal(OnSendInviteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_SendInvite(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Update a lobby given a lobby modification handle created by <see cref="UpdateLobbyModification" />
		/// </summary>
		/// <param name="options">Structure containing information about the lobby to be updated</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">A callback that is fired when the update operation completes, either successfully or in error</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the update completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.LobbyNotOwner" /> if the lobby modification contains modifications that are only allowed by the owner
		/// <see cref="Result.NotFound" /> if the lobby to update does not exist
		/// </returns>
		public void UpdateLobby(UpdateLobbyOptions options, object clientData, OnUpdateLobbyCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<UpdateLobbyOptionsInternal, UpdateLobbyOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnUpdateLobbyCallbackInternal(OnUpdateLobbyCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_Lobby_UpdateLobby(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Creates a lobby modification handle (<see cref="LobbyModification" />). The lobby modification handle is used to modify an existing lobby and can be applied with <see cref="UpdateLobby" />.
		/// The <see cref="LobbyModification" /> must be released by calling <see cref="LobbyModification.Release" /> once it is no longer needed.
		/// <seealso cref="LobbyModification.Release" />
		/// <seealso cref="UpdateLobby" />
		/// <seealso cref="LobbyModification" />
		/// </summary>
		/// <param name="options">Required fields such as lobby ID</param>
		/// <param name="outLobbyModificationHandle">Pointer to a Lobby Modification Handle only set if successful</param>
		/// <returns>
		/// <see cref="Result.Success" /> if we successfully created the Lobby Modification Handle pointed at in OutLobbyModificationHandle, or an error result if the input data was invalid
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public Result UpdateLobbyModification(UpdateLobbyModificationOptions options, out LobbyModification outLobbyModificationHandle)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<UpdateLobbyModificationOptionsInternal, UpdateLobbyModificationOptions>(ref optionsAddress, options);

			var outLobbyModificationHandleAddress = System.IntPtr.Zero;

			var funcResult = Bindings.EOS_Lobby_UpdateLobbyModification(InnerHandle, optionsAddress, ref outLobbyModificationHandleAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outLobbyModificationHandleAddress, out outLobbyModificationHandle);

			return funcResult;
		}

		[MonoPInvokeCallback(typeof(OnCreateLobbyCallbackInternal))]
		internal static void OnCreateLobbyCallbackInternalImplementation(System.IntPtr data)
		{
			OnCreateLobbyCallback callback;
			CreateLobbyCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnCreateLobbyCallback, CreateLobbyCallbackInfoInternal, CreateLobbyCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnDestroyLobbyCallbackInternal))]
		internal static void OnDestroyLobbyCallbackInternalImplementation(System.IntPtr data)
		{
			OnDestroyLobbyCallback callback;
			DestroyLobbyCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnDestroyLobbyCallback, DestroyLobbyCallbackInfoInternal, DestroyLobbyCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnJoinLobbyAcceptedCallbackInternal))]
		internal static void OnJoinLobbyAcceptedCallbackInternalImplementation(System.IntPtr data)
		{
			OnJoinLobbyAcceptedCallback callback;
			JoinLobbyAcceptedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnJoinLobbyAcceptedCallback, JoinLobbyAcceptedCallbackInfoInternal, JoinLobbyAcceptedCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnJoinLobbyCallbackInternal))]
		internal static void OnJoinLobbyCallbackInternalImplementation(System.IntPtr data)
		{
			OnJoinLobbyCallback callback;
			JoinLobbyCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnJoinLobbyCallback, JoinLobbyCallbackInfoInternal, JoinLobbyCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnKickMemberCallbackInternal))]
		internal static void OnKickMemberCallbackInternalImplementation(System.IntPtr data)
		{
			OnKickMemberCallback callback;
			KickMemberCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnKickMemberCallback, KickMemberCallbackInfoInternal, KickMemberCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLeaveLobbyCallbackInternal))]
		internal static void OnLeaveLobbyCallbackInternalImplementation(System.IntPtr data)
		{
			OnLeaveLobbyCallback callback;
			LeaveLobbyCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnLeaveLobbyCallback, LeaveLobbyCallbackInfoInternal, LeaveLobbyCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLobbyInviteAcceptedCallbackInternal))]
		internal static void OnLobbyInviteAcceptedCallbackInternalImplementation(System.IntPtr data)
		{
			OnLobbyInviteAcceptedCallback callback;
			LobbyInviteAcceptedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnLobbyInviteAcceptedCallback, LobbyInviteAcceptedCallbackInfoInternal, LobbyInviteAcceptedCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLobbyInviteReceivedCallbackInternal))]
		internal static void OnLobbyInviteReceivedCallbackInternalImplementation(System.IntPtr data)
		{
			OnLobbyInviteReceivedCallback callback;
			LobbyInviteReceivedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnLobbyInviteReceivedCallback, LobbyInviteReceivedCallbackInfoInternal, LobbyInviteReceivedCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLobbyMemberStatusReceivedCallbackInternal))]
		internal static void OnLobbyMemberStatusReceivedCallbackInternalImplementation(System.IntPtr data)
		{
			OnLobbyMemberStatusReceivedCallback callback;
			LobbyMemberStatusReceivedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnLobbyMemberStatusReceivedCallback, LobbyMemberStatusReceivedCallbackInfoInternal, LobbyMemberStatusReceivedCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLobbyMemberUpdateReceivedCallbackInternal))]
		internal static void OnLobbyMemberUpdateReceivedCallbackInternalImplementation(System.IntPtr data)
		{
			OnLobbyMemberUpdateReceivedCallback callback;
			LobbyMemberUpdateReceivedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnLobbyMemberUpdateReceivedCallback, LobbyMemberUpdateReceivedCallbackInfoInternal, LobbyMemberUpdateReceivedCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnLobbyUpdateReceivedCallbackInternal))]
		internal static void OnLobbyUpdateReceivedCallbackInternalImplementation(System.IntPtr data)
		{
			OnLobbyUpdateReceivedCallback callback;
			LobbyUpdateReceivedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnLobbyUpdateReceivedCallback, LobbyUpdateReceivedCallbackInfoInternal, LobbyUpdateReceivedCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnPromoteMemberCallbackInternal))]
		internal static void OnPromoteMemberCallbackInternalImplementation(System.IntPtr data)
		{
			OnPromoteMemberCallback callback;
			PromoteMemberCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnPromoteMemberCallback, PromoteMemberCallbackInfoInternal, PromoteMemberCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnQueryInvitesCallbackInternal))]
		internal static void OnQueryInvitesCallbackInternalImplementation(System.IntPtr data)
		{
			OnQueryInvitesCallback callback;
			QueryInvitesCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnQueryInvitesCallback, QueryInvitesCallbackInfoInternal, QueryInvitesCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnRTCRoomConnectionChangedCallbackInternal))]
		internal static void OnRTCRoomConnectionChangedCallbackInternalImplementation(System.IntPtr data)
		{
			OnRTCRoomConnectionChangedCallback callback;
			RTCRoomConnectionChangedCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnRTCRoomConnectionChangedCallback, RTCRoomConnectionChangedCallbackInfoInternal, RTCRoomConnectionChangedCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnRejectInviteCallbackInternal))]
		internal static void OnRejectInviteCallbackInternalImplementation(System.IntPtr data)
		{
			OnRejectInviteCallback callback;
			RejectInviteCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnRejectInviteCallback, RejectInviteCallbackInfoInternal, RejectInviteCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnSendInviteCallbackInternal))]
		internal static void OnSendInviteCallbackInternalImplementation(System.IntPtr data)
		{
			OnSendInviteCallback callback;
			SendInviteCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnSendInviteCallback, SendInviteCallbackInfoInternal, SendInviteCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnUpdateLobbyCallbackInternal))]
		internal static void OnUpdateLobbyCallbackInternalImplementation(System.IntPtr data)
		{
			OnUpdateLobbyCallback callback;
			UpdateLobbyCallbackInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnUpdateLobbyCallback, UpdateLobbyCallbackInfoInternal, UpdateLobbyCallbackInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}
	}
}