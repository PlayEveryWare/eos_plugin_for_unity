// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

namespace Epic.OnlineServices.P2P
{
	public sealed partial class P2PInterface : Handle
	{
		public P2PInterface()
		{
		}

		public P2PInterface(System.IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="AcceptConnection" /> API.
		/// </summary>
		public const int AcceptconnectionApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyIncomingPacketQueueFull" /> API.
		/// </summary>
		public const int AddnotifyincomingpacketqueuefullApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyPeerConnectionClosed" /> API.
		/// </summary>
		public const int AddnotifypeerconnectionclosedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyPeerConnectionRequest" /> API.
		/// </summary>
		public const int AddnotifypeerconnectionrequestApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CloseConnection" /> API.
		/// </summary>
		public const int CloseconnectionApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CloseConnections" /> API.
		/// </summary>
		public const int CloseconnectionsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetNATType" /> API.
		/// </summary>
		public const int GetnattypeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetNextReceivedPacketSize" /> API.
		/// </summary>
		public const int GetnextreceivedpacketsizeApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="GetPacketQueueInfo" /> API.
		/// </summary>
		public const int GetpacketqueueinfoApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetPortRange" /> API.
		/// </summary>
		public const int GetportrangeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetRelayControl" /> API.
		/// </summary>
		public const int GetrelaycontrolApiLatest = 1;

		/// <summary>
		/// The maximum amount of unique Socket ID connections that can be opened with each remote user. As this limit is only per remote user, you may have more
		/// than this number of Socket IDs across multiple remote users.
		/// </summary>
		public const int MaxConnections = 32;

		/// <summary>
		/// A packet's maximum size in bytes
		/// </summary>
		public const int MaxPacketSize = 1170;

		/// <summary>
		/// Helper constant to signify that the packet queue is allowed to grow indefinitely
		/// </summary>
		public const int MaxQueueSizeUnlimited = 0;

		/// <summary>
		/// The most recent version of the <see cref="QueryNATType" /> API.
		/// </summary>
		public const int QuerynattypeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="ReceivePacket" /> API.
		/// </summary>
		public const int ReceivepacketApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="SendPacket" /> API.
		/// </summary>
		public const int SendpacketApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="SetPacketQueueSize" /> API.
		/// </summary>
		public const int SetpacketqueuesizeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="SetPortRange" /> API.
		/// </summary>
		public const int SetportrangeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="SetRelayControl" /> API.
		/// </summary>
		public const int SetrelaycontrolApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="SocketId" /> structure.
		/// </summary>
		public const int SocketidApiLatest = 1;

		/// <summary>
		/// Accept connections from a specific peer. If this peer has not attempted to connect yet, when they do, they will automatically be accepted.
		/// </summary>
		/// <param name="options">Information about who would like to accept a connection, and which connection</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the provided data is valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the provided data is invalid
		/// </returns>
		public Result AcceptConnection(AcceptConnectionOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AcceptConnectionOptionsInternal, AcceptConnectionOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_P2P_AcceptConnection(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Listen for when our packet queue has become full. This event gives an opportunity to read packets to make
		/// room for new incoming packets. If this event fires and no packets are read by calling <see cref="ReceivePacket" />
		/// or the packet queue size is not increased by <see cref="SetPacketQueueSize" />, any packets that are received after
		/// this event are discarded until there is room again in the queue.
		/// </summary>
		/// <param name="options">Information about what version of the <see cref="AddNotifyIncomingPacketQueueFull" /> API is supported</param>
		/// <param name="clientData">Arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="incomingPacketQueueFullHandler">The callback to be fired when the incoming packet queue is full</param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.InvalidNotificationid" /> otherwise
		/// </returns>
		public ulong AddNotifyIncomingPacketQueueFull(AddNotifyIncomingPacketQueueFullOptions options, object clientData, OnIncomingPacketQueueFullCallback incomingPacketQueueFullHandler)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyIncomingPacketQueueFullOptionsInternal, AddNotifyIncomingPacketQueueFullOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var incomingPacketQueueFullHandlerInternal = new OnIncomingPacketQueueFullCallbackInternal(OnIncomingPacketQueueFullCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, incomingPacketQueueFullHandler, incomingPacketQueueFullHandlerInternal);

			var funcResult = Bindings.EOS_P2P_AddNotifyIncomingPacketQueueFull(InnerHandle, optionsAddress, clientDataAddress, incomingPacketQueueFullHandlerInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Listen for when a previously opened connection is closed.
		/// </summary>
		/// <param name="options">Information about who would like notifications about closed connections, and for which socket</param>
		/// <param name="clientData">This value is returned to the caller when ConnectionClosedHandler is invoked</param>
		/// <param name="connectionClosedHandler">The callback to be fired when we an open connection has been closed</param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.InvalidNotificationid" /> otherwise
		/// </returns>
		public ulong AddNotifyPeerConnectionClosed(AddNotifyPeerConnectionClosedOptions options, object clientData, OnRemoteConnectionClosedCallback connectionClosedHandler)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyPeerConnectionClosedOptionsInternal, AddNotifyPeerConnectionClosedOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var connectionClosedHandlerInternal = new OnRemoteConnectionClosedCallbackInternal(OnRemoteConnectionClosedCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, connectionClosedHandler, connectionClosedHandlerInternal);

			var funcResult = Bindings.EOS_P2P_AddNotifyPeerConnectionClosed(InnerHandle, optionsAddress, clientDataAddress, connectionClosedHandlerInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Listen for incoming connection requests on a particular Socket ID, or optionally all Socket IDs. The bound function
		/// will only be called if the connection has not already been accepted.
		/// </summary>
		/// <param name="options">Information about who would like notifications, and (optionally) only for a specific socket</param>
		/// <param name="clientData">This value is returned to the caller when ConnectionRequestHandler is invoked</param>
		/// <param name="connectionRequestHandler">The callback to be fired when we receive a connection request</param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.InvalidNotificationid" /> otherwise
		/// </returns>
		public ulong AddNotifyPeerConnectionRequest(AddNotifyPeerConnectionRequestOptions options, object clientData, OnIncomingConnectionRequestCallback connectionRequestHandler)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<AddNotifyPeerConnectionRequestOptionsInternal, AddNotifyPeerConnectionRequestOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var connectionRequestHandlerInternal = new OnIncomingConnectionRequestCallbackInternal(OnIncomingConnectionRequestCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, connectionRequestHandler, connectionRequestHandlerInternal);

			var funcResult = Bindings.EOS_P2P_AddNotifyPeerConnectionRequest(InnerHandle, optionsAddress, clientDataAddress, connectionRequestHandlerInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			return funcResult;
		}

		/// <summary>
		/// Stop accepting new connections from a specific peer and close any open connections.
		/// </summary>
		/// <param name="options">Information about who would like to close a connection, and which connection.</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the provided data is valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the provided data is invalid
		/// </returns>
		public Result CloseConnection(CloseConnectionOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CloseConnectionOptionsInternal, CloseConnectionOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_P2P_CloseConnection(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Close any open Connections for a specific Peer Connection ID.
		/// </summary>
		/// <param name="options">Information about who would like to close connections, and by what socket ID</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the provided data is valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the provided data is invalid
		/// </returns>
		public Result CloseConnections(CloseConnectionsOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<CloseConnectionsOptionsInternal, CloseConnectionsOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_P2P_CloseConnections(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Get our last-queried NAT-type, if it has been successfully queried.
		/// </summary>
		/// <param name="options">Information about what version of the <see cref="GetNATType" /> API is supported</param>
		/// <param name="outNATType">The queried NAT Type, or unknown if unknown</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if we have cached data
		/// <see cref="Result" />::<see cref="Result.NotFound" /> - If we do not have queried data cached
		/// </returns>
		public Result GetNATType(GetNATTypeOptions options, out NATType outNATType)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetNATTypeOptionsInternal, GetNATTypeOptions>(ref optionsAddress, options);

			outNATType = Helper.GetDefault<NATType>();

			var funcResult = Bindings.EOS_P2P_GetNATType(InnerHandle, optionsAddress, ref outNATType);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Gets the size of the packet that will be returned by ReceivePacket for a particular user, if there is any available
		/// packets to be retrieved.
		/// </summary>
		/// <param name="options">Information about who is requesting the size of their next packet</param>
		/// <param name="outPacketSizeBytes">The amount of bytes required to store the data of the next packet for the requested user</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - If OutPacketSizeBytes was successfully set and there is data to be received
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - If input was invalid
		/// <see cref="Result" />::<see cref="Result.NotFound" /> - If there are no packets available for the requesting user
		/// </returns>
		public Result GetNextReceivedPacketSize(GetNextReceivedPacketSizeOptions options, out uint outPacketSizeBytes)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetNextReceivedPacketSizeOptionsInternal, GetNextReceivedPacketSizeOptions>(ref optionsAddress, options);

			outPacketSizeBytes = Helper.GetDefault<uint>();

			var funcResult = Bindings.EOS_P2P_GetNextReceivedPacketSize(InnerHandle, optionsAddress, ref outPacketSizeBytes);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Gets the current cached information related to the incoming and outgoing packet queues.
		/// </summary>
		/// <param name="options">Information about what version of the <see cref="GetPacketQueueInfo" /> API is supported</param>
		/// <param name="outPacketQueueInfo">The current information of the incoming and outgoing packet queues</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the input options were valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the input was invalid in some way
		/// </returns>
		public Result GetPacketQueueInfo(GetPacketQueueInfoOptions options, out PacketQueueInfo outPacketQueueInfo)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetPacketQueueInfoOptionsInternal, GetPacketQueueInfoOptions>(ref optionsAddress, options);

			var outPacketQueueInfoInternal = Helper.GetDefault<PacketQueueInfoInternal>();

			var funcResult = Bindings.EOS_P2P_GetPacketQueueInfo(InnerHandle, optionsAddress, ref outPacketQueueInfoInternal);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outPacketQueueInfoInternal, out outPacketQueueInfo);

			return funcResult;
		}

		/// <summary>
		/// Get the current chosen port and the amount of other ports to try above the chosen port if the chosen port is unavailable.
		/// </summary>
		/// <param name="options">Information about what version of the <see cref="GetPortRange" /> API is supported</param>
		/// <param name="outPort">The port that will be tried first</param>
		/// <param name="outNumAdditionalPortsToTry">The amount of ports to try above the value in OutPort, if OutPort is unavailable</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the input options were valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the input was invalid in some way
		/// </returns>
		public Result GetPortRange(GetPortRangeOptions options, out ushort outPort, out ushort outNumAdditionalPortsToTry)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetPortRangeOptionsInternal, GetPortRangeOptions>(ref optionsAddress, options);

			outPort = Helper.GetDefault<ushort>();

			outNumAdditionalPortsToTry = Helper.GetDefault<ushort>();

			var funcResult = Bindings.EOS_P2P_GetPortRange(InnerHandle, optionsAddress, ref outPort, ref outNumAdditionalPortsToTry);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Get the current relay control setting.
		/// </summary>
		/// <param name="options">Information about what version of the <see cref="GetRelayControl" /> API is supported</param>
		/// <param name="outRelayControl">The relay control setting currently configured</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the input was valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the input was invalid in some way
		/// </returns>
		public Result GetRelayControl(GetRelayControlOptions options, out RelayControl outRelayControl)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<GetRelayControlOptionsInternal, GetRelayControlOptions>(ref optionsAddress, options);

			outRelayControl = Helper.GetDefault<RelayControl>();

			var funcResult = Bindings.EOS_P2P_GetRelayControl(InnerHandle, optionsAddress, ref outRelayControl);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Query the current NAT-type of our connection.
		/// </summary>
		/// <param name="options">Information about what version of the <see cref="QueryNATType" /> API is supported</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">The callback to be fired when we finish querying our NAT type</param>
		public void QueryNATType(QueryNATTypeOptions options, object clientData, OnQueryNATTypeCompleteCallback completionDelegate)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<QueryNATTypeOptionsInternal, QueryNATTypeOptions>(ref optionsAddress, options);

			var clientDataAddress = System.IntPtr.Zero;

			var completionDelegateInternal = new OnQueryNATTypeCompleteCallbackInternal(OnQueryNATTypeCompleteCallbackInternalImplementation);
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			Bindings.EOS_P2P_QueryNATType(InnerHandle, optionsAddress, clientDataAddress, completionDelegateInternal);

			Helper.TryMarshalDispose(ref optionsAddress);
		}

		/// <summary>
		/// Receive the next packet for the local user, and information associated with this packet, if it exists.
		/// </summary>
		/// <param name="options">Information about who is requesting the size of their next packet, and how much data can be stored safely</param>
		/// <param name="outPeerId">The Remote User who sent data. Only set if there was a packet to receive.</param>
		/// <param name="outSocketId">The Socket ID of the data that was sent. Only set if there was a packet to receive.</param>
		/// <param name="outChannel">The channel the data was sent on. Only set if there was a packet to receive.</param>
		/// <param name="outData">Buffer to store the data being received. Must be at least <see cref="GetNextReceivedPacketSize" /> in length or data will be truncated</param>
		/// <param name="outBytesWritten">The amount of bytes written to OutData. Only set if there was a packet to receive.</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - If the packet was received successfully
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - If input was invalid
		/// <see cref="Result" />::<see cref="Result.NotFound" /> - If there are no packets available for the requesting user
		/// </returns>
		public Result ReceivePacket(ReceivePacketOptions options, out ProductUserId outPeerId, out SocketId outSocketId, out byte outChannel, out byte[] outData)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<ReceivePacketOptionsInternal, ReceivePacketOptions>(ref optionsAddress, options);

			var outPeerIdAddress = System.IntPtr.Zero;

			var outSocketIdInternal = Helper.GetDefault<SocketIdInternal>();

			outChannel = Helper.GetDefault<byte>();

			System.IntPtr outDataAddress = System.IntPtr.Zero;
			uint outBytesWritten = MaxPacketSize;
			Helper.TryMarshalAllocate(ref outDataAddress, outBytesWritten, out _);

			var funcResult = Bindings.EOS_P2P_ReceivePacket(InnerHandle, optionsAddress, ref outPeerIdAddress, ref outSocketIdInternal, ref outChannel, outDataAddress, ref outBytesWritten);

			Helper.TryMarshalDispose(ref optionsAddress);

			Helper.TryMarshalGet(outPeerIdAddress, out outPeerId);

			Helper.TryMarshalGet(outSocketIdInternal, out outSocketId);

			Helper.TryMarshalGet(outDataAddress, out outData, outBytesWritten);
			Helper.TryMarshalDispose(ref outDataAddress);

			return funcResult;
		}

		/// <summary>
		/// Stop listening for full incoming packet queue events on a previously bound handler.
		/// </summary>
		/// <param name="notificationId">The previously bound notification ID</param>
		public void RemoveNotifyIncomingPacketQueueFull(ulong notificationId)
		{
			Helper.TryRemoveCallbackByNotificationId(notificationId);

			Bindings.EOS_P2P_RemoveNotifyIncomingPacketQueueFull(InnerHandle, notificationId);
		}

		/// <summary>
		/// Stop notifications for connections being closed on a previously bound handler.
		/// </summary>
		/// <param name="notificationId">The previously bound notification ID</param>
		public void RemoveNotifyPeerConnectionClosed(ulong notificationId)
		{
			Helper.TryRemoveCallbackByNotificationId(notificationId);

			Bindings.EOS_P2P_RemoveNotifyPeerConnectionClosed(InnerHandle, notificationId);
		}

		/// <summary>
		/// Stop listening for connection requests on a previously bound handler.
		/// </summary>
		/// <param name="notificationId">The previously bound notification ID</param>
		public void RemoveNotifyPeerConnectionRequest(ulong notificationId)
		{
			Helper.TryRemoveCallbackByNotificationId(notificationId);

			Bindings.EOS_P2P_RemoveNotifyPeerConnectionRequest(InnerHandle, notificationId);
		}

		/// <summary>
		/// Send a packet to a peer at the specified address. If there is already an open connection to this peer, it will be
		/// sent immediately. If there is no open connection, an attempt to connect to the peer will be made. An <see cref="Result.Success" />
		/// result only means the data was accepted to be sent, not that it has been successfully delivered to the peer.
		/// </summary>
		/// <param name="options">Information about the data being sent, by who, to who</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - If packet was queued to be sent successfully
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - If input was invalid
		/// <see cref="Result" />::<see cref="Result.LimitExceeded" /> - If amount of data being sent is too large, or the outgoing packet queue was full
		/// </returns>
		public Result SendPacket(SendPacketOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<SendPacketOptionsInternal, SendPacketOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_P2P_SendPacket(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Sets the maximum packet queue sizes that packets waiting to be sent or received can use. If the packet queue
		/// size is made smaller than the current queue size while there are packets in the queue that would push this
		/// packet size over, existing packets are kept but new packets may not be added to the full queue until enough
		/// packets are sent or received.
		/// </summary>
		/// <param name="options">Information about packet queue size</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the input options were valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the input was invalid in some way
		/// </returns>
		public Result SetPacketQueueSize(SetPacketQueueSizeOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<SetPacketQueueSizeOptionsInternal, SetPacketQueueSizeOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_P2P_SetPacketQueueSize(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Set configuration options related to network ports.
		/// </summary>
		/// <param name="options">Information about network ports config options</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the options were set successfully
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the options are invalid in some way
		/// </returns>
		public Result SetPortRange(SetPortRangeOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<SetPortRangeOptionsInternal, SetPortRangeOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_P2P_SetPortRange(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		/// <summary>
		/// Set how relay servers are to be used. This setting does not immediately apply to existing connections, but may apply to existing
		/// connections if the connection requires renegotiation.
		/// </summary>
		/// <param name="options">Information about relay server config options</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the options were set successfully
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the options are invalid in some way
		/// </returns>
		public Result SetRelayControl(SetRelayControlOptions options)
		{
			var optionsAddress = System.IntPtr.Zero;
			Helper.TryMarshalSet<SetRelayControlOptionsInternal, SetRelayControlOptions>(ref optionsAddress, options);

			var funcResult = Bindings.EOS_P2P_SetRelayControl(InnerHandle, optionsAddress);

			Helper.TryMarshalDispose(ref optionsAddress);

			return funcResult;
		}

		[MonoPInvokeCallback(typeof(OnIncomingConnectionRequestCallbackInternal))]
		internal static void OnIncomingConnectionRequestCallbackInternalImplementation(System.IntPtr data)
		{
			OnIncomingConnectionRequestCallback callback;
			OnIncomingConnectionRequestInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnIncomingConnectionRequestCallback, OnIncomingConnectionRequestInfoInternal, OnIncomingConnectionRequestInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnIncomingPacketQueueFullCallbackInternal))]
		internal static void OnIncomingPacketQueueFullCallbackInternalImplementation(System.IntPtr data)
		{
			OnIncomingPacketQueueFullCallback callback;
			OnIncomingPacketQueueFullInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnIncomingPacketQueueFullCallback, OnIncomingPacketQueueFullInfoInternal, OnIncomingPacketQueueFullInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnQueryNATTypeCompleteCallbackInternal))]
		internal static void OnQueryNATTypeCompleteCallbackInternalImplementation(System.IntPtr data)
		{
			OnQueryNATTypeCompleteCallback callback;
			OnQueryNATTypeCompleteInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnQueryNATTypeCompleteCallback, OnQueryNATTypeCompleteInfoInternal, OnQueryNATTypeCompleteInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback(typeof(OnRemoteConnectionClosedCallbackInternal))]
		internal static void OnRemoteConnectionClosedCallbackInternalImplementation(System.IntPtr data)
		{
			OnRemoteConnectionClosedCallback callback;
			OnRemoteConnectionClosedInfo callbackInfo;
			if (Helper.TryGetAndRemoveCallback<OnRemoteConnectionClosedCallback, OnRemoteConnectionClosedInfoInternal, OnRemoteConnectionClosedInfo>(data, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}
	}
}