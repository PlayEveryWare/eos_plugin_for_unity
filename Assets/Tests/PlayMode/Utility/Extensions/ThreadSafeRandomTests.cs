/*
 * Copyright (c) 2024 PlayEveryWare
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

namespace PlayEveryWare.EpicOnlineServices.Tests.Utility.Extensions
{
    using EpicOnlineServices.Extensions;
    using NUnit.Framework;
    using System;
    using System.Collections.Concurrent;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;

    [TestFixture]
    public class ThreadSafeRandomTests
    {
        /// <summary>
        /// Test to verify that each thread gets its own instance of Random.
        /// </summary>
        [Test]
        public void Instance_IsThreadLocal()
        {
            // Use a ConcurrentDictionary to store Random instances by thread ID
            ConcurrentDictionary<int, Random> randomInstances = new();

            // Run tasks in parallel to access ThreadSafeRandom.Instance
            Parallel.For(0, 100, _ =>
            {
                int threadId = Thread.CurrentThread.ManagedThreadId;
                Random random = ThreadSafeRandom.Instance;
                randomInstances.TryAdd(threadId, random);
            });

            // Assert that each thread has its own unique Random instance
            Assert.AreEqual(randomInstances.Count, randomInstances.Values.Distinct().Count(),
                "Each thread should have its own unique Random instance.");
        }

        /// <summary>
        /// Test to verify that random numbers generated by each thread are not identical.
        /// </summary>
        [Test]
        public void RandomValues_AreNotIdenticalAcrossThreads()
        {
            // Use a ConcurrentBag to collect random values generated by each thread
            ConcurrentBag<int> randomValues = new();

            // Run tasks in parallel to generate random numbers
            Parallel.For(0, 100, _ =>
            {
                Random random = ThreadSafeRandom.Instance;
                int randomValue = random.Next();
                randomValues.Add(randomValue);
            });

            // Assert that not all random values are identical (expect some variety)
            Assert.Greater(randomValues.Distinct().Count(), 1,
                "Random values generated by different threads should not all be identical.");
        }

        /// <summary>
        /// Test to verify that accessing ThreadSafeRandom.Instance does not throw any exceptions.
        /// </summary>
        [Test]
        public void Instance_DoesNotThrowException()
        {
            // Use a simple loop to access ThreadSafeRandom.Instance multiple times
            Assert.DoesNotThrow(() =>
            {
                for (int i = 0; i < 100; i++)
                {
                    _ = ThreadSafeRandom.Instance.Next();
                }
            }, "Accessing ThreadSafeRandom.Instance should not throw any exceptions.");
        }
    }
}